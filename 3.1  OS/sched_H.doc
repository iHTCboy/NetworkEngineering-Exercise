{\rtf1\ansi\ansicpg936\uc2\deff0\stshfdbch13\stshfloch0\stshfhich0\stshfbi0\deflang1033\deflangfe2052{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}{\f13\fnil\fcharset134\fprq2{\*\panose 02010600030101010101}\'cb\'ce\'cc\'e5{\*\falt SimSun};}{\f35\fnil\fcharset134\fprq2{\*\panose 00000000000000000000}@\'cb\'ce\'cc\'e5;}
{\f37\froman\fcharset238\fprq2 Times New Roman CE;}{\f38\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f40\froman\fcharset161\fprq2 Times New Roman Greek;}{\f41\froman\fcharset162\fprq2 Times New Roman Tur;}
{\f42\froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f43\froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f44\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f45\froman\fcharset163\fprq2 Times New Roman (Vietnamese);}
{\f57\fmodern\fcharset238\fprq1 Courier New CE;}{\f58\fmodern\fcharset204\fprq1 Courier New Cyr;}{\f60\fmodern\fcharset161\fprq1 Courier New Greek;}{\f61\fmodern\fcharset162\fprq1 Courier New Tur;}{\f62\fmodern\fcharset177\fprq1 Courier New (Hebrew);}
{\f63\fmodern\fcharset178\fprq1 Courier New (Arabic);}{\f64\fmodern\fcharset186\fprq1 Courier New Baltic;}{\f65\fmodern\fcharset163\fprq1 Courier New (Vietnamese);}{\f169\fnil\fcharset0\fprq2 SimSun Western{\*\falt SimSun};}
{\f389\fnil\fcharset0\fprq2 @\'cb\'ce\'cc\'e5 Western;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;
\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{
\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs21\lang1033\langfe2052\kerning2\loch\f0\hich\af0\dbch\af13\cgrid\langnp1033\langfenp2052 \snext0 Normal;}{\*\cs10 \additive \ssemihidden Default Paragraph Font;}{\*
\ts11\tsrowd\trftsWidthB3\trpaddl108\trpaddr108\trpaddfl3\trpaddft3\trpaddfb3\trpaddfr3\trcbpat1\trcfpat1\tscellwidthfts0\tsvertalt\tsbrdrt\tsbrdrl\tsbrdrb\tsbrdrr\tsbrdrdgl\tsbrdrdgr\tsbrdrh\tsbrdrv 
\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1024\langfe1024\loch\f0\hich\af0\dbch\af13\cgrid\langnp1024\langfenp1024 \snext11 \ssemihidden Normal Table;}{
\s15\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs21\lang1033\langfe2052\kerning2\loch\f13\hich\af2\dbch\af13\cgrid\langnp1033\langfenp2052 \sbasedon0 \snext15 Plain Text;}}{\*\latentstyles\lsdstimax156\lsdlockeddef0}
{\*\rsidtbl \rsid19142\rsid721367\rsid1068131\rsid1114342\rsid1257417\rsid1601431\rsid1712697\rsid2181323\rsid2305625\rsid2558391\rsid2824020\rsid2838352\rsid2892992\rsid3618242\rsid3831200\rsid4028773\rsid4353300\rsid4466615\rsid4471939\rsid4858544
\rsid5780670\rsid5923536\rsid6314868\rsid7305034\rsid7610296\rsid8335250\rsid8930903\rsid9056743\rsid9062547\rsid9266659\rsid9600920\rsid9899319\rsid10225817\rsid10314595\rsid10487966\rsid11300733\rsid11556185\rsid12538393\rsid12806999\rsid13308640
\rsid13328319\rsid13519943\rsid13897779\rsid14168890\rsid14501447\rsid15094660\rsid15432943\rsid16062596\rsid16063122\rsid16268027\rsid16477490\rsid16718750}{\*\generator Microsoft Word 11.0.5604;}{\info{\title #ifndef _LINUX_SCHED_H}{\author zhl}
{\operator zhl}{\creatim\yr2013\mo9\dy16\hr22\min49}{\revtim\yr2013\mo10\dy4\hr10\min10}{\version50}{\edmins95}{\nofpages22}{\nofwords4105}{\nofchars23405}{\*\company dellmini}{\nofcharsws27456}{\vern24689}}
\paperw11906\paperh16838\margl1753\margr1753\margt1440\margb1440\gutter0 \deftab420\ftnbj\aenddoc\hyphcaps0\formshade\horzdoc\dgmargin\dghspace180\dgvspace156\dghorigin1753\dgvorigin1440\dghshow0\dgvshow2\jcompress\lnongrid
\viewkind1\viewscale100\splytwnine\ftnlytwnine\htmautsp\useltbaln\alntblind\lytcalctblwd\lyttblrtgr\lnbrkrule\nobrkwrptbl\viewnobound1\snaptogridincell\allowfieldendsel\wrppunct\asianbrkrule\rsidroot10314595\newtblstyruls\nogrowautofit {\*\fchars 
!),.:\'3b?]\'7d\'a1\'a7\'a1\'a4\'a1\'a6\'a1\'a5\'a8\'44\'a1\'ac\'a1\'af\'a1\'b1\'a1\'ad\'a1\'c3\'a1\'a2\'a1\'a3\'a1\'a8\'a1\'a9\'a1\'b5\'a1\'b7\'a1\'b9\'a1\'bb\'a1\'bf\'a1\'b3\'a1\'bd\'a3\'a1\'a3\'a2\'a3\'a7\'a3\'a9\'a3\'ac\'a3\'ae\'a3\'ba\'a3\'bb\'a3\'bf\'a3\'dd\'a3\'e0\'a3\'fc\'a3\'fd\'a1\'ab\'a1\'e9
}{\*\lchars ([\'7b\'a1\'a4\'a1\'ae\'a1\'b0\'a1\'b4\'a1\'b6\'a1\'b8\'a1\'ba\'a1\'be\'a1\'b2\'a1\'bc\'a3\'a8\'a3\'ae\'a3\'db\'a3\'fb\'a1\'ea\'a3\'a4}\fet0\sectd 
\linex0\headery851\footery992\colsx425\endnhere\sectlinegrid312\sectspecifyl\sectrsid3618242\sftnbj {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang {\pntxta \dbch .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang {\pntxta \dbch .}}{\*\pnseclvl3
\pndec\pnstart1\pnindent720\pnhang {\pntxta \dbch .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang {\pntxta \dbch )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang {\pntxtb \dbch (}{\pntxta \dbch )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang 
{\pntxtb \dbch (}{\pntxta \dbch )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb \dbch (}{\pntxta \dbch )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb \dbch (}{\pntxta \dbch )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang 
{\pntxtb \dbch (}{\pntxta \dbch )}}\pard\plain \s15\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid3618242 \fs21\lang1033\langfe2052\kerning2\loch\af13\hich\af2\dbch\af13\cgrid\langnp1033\langfenp2052 {
\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 #ifndef _LINUX_SCHED_H
\par \hich\af13\dbch\af13\loch\f13 #define _LINUX_SCHED_H
\par 
\par \hich\af13\dbch\af13\loch\f13 #include <asm/param.h>\tab /* for HZ */
\par 
\par \hich\af13\dbch\af13\loch\f13 extern unsigned long event;
\par 
\par \hich\af13\dbch\af13\loch\f13 #include <linux/config.h>
\par \hich\af13\dbch\af13\loch\f13 #include <linux/binfmts.h>
\par \hich\af13\dbch\af13\loch\f13 #include <linux/personality.h>
\par \hich\af13\dbch\af13\loch\f13 #include <linux/threads.h>
\par \hich\af13\dbch\af13\loch\f13 #include <linux/kernel.h>
\par \hich\af13\dbch\af13\loch\f13 #include <linux/types.h>
\par \hich\af13\dbch\af13\loch\f13 #include <linux/times.h>
\par \hich\af13\dbch\af13\loch\f13 #include <linux/timex.h>
\par 
\par \hich\af13\dbch\af13\loch\f13 #include <asm/system.h>
\par \hich\af13\dbch\af13\loch\f13 #include <asm/semap\hich\af13\dbch\af13\loch\f13 hore.h>
\par \hich\af13\dbch\af13\loch\f13 #include <asm/page.h>
\par \hich\af13\dbch\af13\loch\f13 #include <asm/ptrace.h>
\par \hich\af13\dbch\af13\loch\f13 #include <asm/mmu.h>
\par 
\par \hich\af13\dbch\af13\loch\f13 #include <linux/smp.h>
\par \hich\af13\dbch\af13\loch\f13 #include <linux/tty.h>
\par \hich\af13\dbch\af13\loch\f13 #include <linux/sem.h>
\par \hich\af13\dbch\af13\loch\f13 #include <linux/signal.h>
\par \hich\af13\dbch\af13\loch\f13 #include <linux/securebits.h>
\par \hich\af13\dbch\af13\loch\f13 #include <linux/fs_struct.h>
\par 
\par \hich\af13\dbch\af13\loch\f13 /*
\par \hich\af13\dbch\af13\loch\f13  * cloning flags:
\par \hich\af13\dbch\af13\loch\f13  */
\par \hich\af13\dbch\af13\loch\f13 #define CSIGNAL\tab \tab 0x000000ff\tab /* signal mask to be sent at exit */
\par \hich\af13\dbch\af13\loch\f13 #define CLONE_VM\tab 0x00000100\tab /* set if VM shared between processes */
\par \hich\af13\dbch\af13\loch\f13 #define CLONE_FS\tab 0x00000200\tab /* set if fs info shared between processes */
\par \hich\af13\dbch\af13\loch\f13 #define CLONE_FILES\tab 0x00000400\tab /* set if open fi\hich\af13\dbch\af13\loch\f13 les shared between processes */
\par \hich\af13\dbch\af13\loch\f13 #define CLONE_SIGHAND\tab 0x00000800\tab /* set if signal handlers and blocked signals shared */
\par \hich\af13\dbch\af13\loch\f13 #define CLONE_PID\tab 0x00001000\tab /* set if pid shared */
\par \hich\af13\dbch\af13\loch\f13 #define CLONE_PTRACE\tab 0x00002000\tab /* set if we want to let tracing continue on the c\hich\af13\dbch\af13\loch\f13 hild too */
\par \hich\af13\dbch\af13\loch\f13 #define CLONE_VFORK\tab 0x00004000\tab /* set if the parent wants the child to wake it up on mm_release */
\par \hich\af13\dbch\af13\loch\f13 #define CLONE_PARENT\tab 0x00008000\tab /* set if we want to have the same parent as the cloner */
\par \hich\af13\dbch\af13\loch\f13 #define CLONE_THREAD\tab 0x00010000\tab /* Same thread group? \hich\af13\dbch\af13\loch\f13 */
\par 
\par \hich\af13\dbch\af13\loch\f13 #define CLONE_SIGNAL\tab (CLONE_SIGHAND | CLONE_THREAD)
\par 
\par \hich\af13\dbch\af13\loch\f13 /*
\par \hich\af13\dbch\af13\loch\f13  * These are the constant used to fake the fixed-point load-average
\par \hich\af13\dbch\af13\loch\f13  * counting. Some notes:
\par \hich\af13\dbch\af13\loch\f13  *  - 11 bit fractions expand to 22 bits by the multiplies: this gives
\par \hich\af13\dbch\af13\loch\f13  *    a load-average precision o\hich\af13\dbch\af13\loch\f13 f 10 bits integer + 11 bits fractional
\par \hich\af13\dbch\af13\loch\f13  *  - if you want to count load-averages more often, you need more
\par \hich\af13\dbch\af13\loch\f13  *    precision, or rounding will get you. With 2-second counting freq,
\par \hich\af13\dbch\af13\loch\f13  *    the EXP_n values would be 1981, 2034 and 2043 if still using only
\par \hich\af13\dbch\af13\loch\f13  *    \hich\af13\dbch\af13\loch\f13 11 bit fractions.
\par \hich\af13\dbch\af13\loch\f13  */
\par \hich\af13\dbch\af13\loch\f13 extern unsigned long avenrun[];\tab \tab /* Load averages */
\par 
\par \hich\af13\dbch\af13\loch\f13 #define FSHIFT\tab \tab 11\tab \tab /* nr of bits of precision */
\par \hich\af13\dbch\af13\loch\f13 #define FIXED_1\tab \tab (1<<FSHIFT)\tab /* 1.0 as fixed-point */
\par \hich\af13\dbch\af13\loch\f13 #define LOAD_FREQ\tab (5*HZ)\tab \tab /* 5 sec intervals */
\par \hich\af13\dbch\af13\loch\f13 #define EXP_1\tab \tab 1884\tab \tab /* 1/ex\hich\af13\dbch\af13\loch\f13 p(5sec/1min) as fixed-point */
\par \hich\af13\dbch\af13\loch\f13 #define EXP_5\tab \tab 2014\tab \tab /* 1/exp(5sec/5min) */
\par \hich\af13\dbch\af13\loch\f13 #define EXP_15\tab \tab 2037\tab \tab /* 1/exp(5sec/15min) */
\par 
\par \hich\af13\dbch\af13\loch\f13 #define CALC_LOAD(load,exp,n) \\
\par \tab \hich\af13\dbch\af13\loch\f13 load *= exp; \\
\par \tab \hich\af13\dbch\af13\loch\f13 load += n*(FIXED_1-exp); \\
\par \tab \hich\af13\dbch\af13\loch\f13 load >>= FSHIFT;
\par 
\par \hich\af13\dbch\af13\loch\f13 #define CT_TO_SECS(x)\tab ((x) / HZ)
\par \hich\af13\dbch\af13\loch\f13 #define CT_TO_USECS(x)\tab (((x) % HZ) * 1000000/HZ)
\par 
\par \hich\af13\dbch\af13\loch\f13 extern int nr_running, nr_threads;
\par \hich\af13\dbch\af13\loch\f13 extern int last_pid;
\par 
\par \hich\af13\dbch\af13\loch\f13 #include <linux/fs.h>
\par \hich\af13\dbch\af13\loch\f13 #include <linux/time.h>
\par \hich\af13\dbch\af13\loch\f13 #include <linux/param.h>
\par \hich\af13\dbch\af13\loch\f13 #include <linux/resource.h>
\par \hich\af13\dbch\af13\loch\f13 #include <linux/timer.h>
\par 
\par \hich\af13\dbch\af13\loch\f13 #include <asm/processor.\hich\af13\dbch\af13\loch\f13 h>
\par 
\par \hich\af13\dbch\af13\loch\f13 #define TASK_RUNNING\tab \tab 0}{\hich\af13\insrsid15094660 \hich\af13\dbch\af13\loch\f13  }{\cf6\hich\af13\insrsid15094660\charrsid15094660 \loch\af13\hich\af13\dbch\f13 \'bf\'c9\'d4\'cb\'d0\'d0\'cc\'ac}{
\cf6\hich\af13\insrsid3831200 \hich\af13\dbch\af13\loch\f13 ,}{\cf6\hich\af13\insrsid3831200 \loch\af13\hich\af13\dbch\f13 \'d4\'cb\'d0\'d0\'d7\'b4\'cc\'ac}{\hich\af13\insrsid10314595\charrsid10314595 
\par }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 #define TASK_INTERRUPTIBLE\tab 1}{\hich\af13\insrsid15094660 \hich\af13\dbch\af13\loch\f13  }{\cf6\hich\af13\insrsid15094660\charrsid15094660 \loch\af13\hich\af13\dbch\f13 
\'bf\'c9\'d6\'d0\'b6\'cf\'b5\'c4\'b5\'c8\'b4\'fd\'cc\'ac}{\cf6\hich\af13\insrsid3831200 \hich\af13\dbch\af13\loch\f13 ,}{\cf6\hich\af13\insrsid3831200 \loch\af13\hich\af13\dbch\f13 \'bf\'c9\'d2\'d4\'c8\'c3\'c6\'e4\'cb\'fb\'bd\'f8\'b3\'cc\'bb\'bd\'d0\'d1}{
\hich\af13\insrsid10314595\charrsid10314595 
\par }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 #define TASK_UNINTERRUPTIBLE\tab 2}{\hich\af13\insrsid15094660 \hich\af13\dbch\af13\loch\f13  }{\cf6\hich\af13\insrsid15094660\charrsid15094660 \loch\af13\hich\af13\dbch\f13 
\'b2\'bb\'bf\'c9\'d6\'d0\'b6\'cf\'b5\'c4\'b5\'c8\'b4\'fd\'cc\'ac}{\cf6\hich\af13\insrsid3831200 \hich\af13\dbch\af13\loch\f13 ,}{\cf6\hich\af13\insrsid3831200 \loch\af13\hich\af13\dbch\f13 \'b2\'bb\'c8\'c3\'c6\'e4\'cb\'fb\'bd\'f8\'b3\'cc\'bb\'bd\'d0\'d1}{
\cf6\hich\af13\insrsid10314595\charrsid15094660 
\par }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 #define TASK_ZOMBIE\tab \tab 4}{\hich\af13\insrsid15094660 \hich\af13\dbch\af13\loch\f13  }{\cf6\hich\af13\insrsid15094660\charrsid15094660 \loch\af13\hich\af13\dbch\f13 \'bd\'a9
\'cb\'c0\'cc\'ac}{\cf6\hich\af13\insrsid15094660\charrsid15094660 \hich\af13\dbch\af13\loch\f13 ,}{\cf6\hich\af13\insrsid15094660\charrsid15094660 \loch\af13\hich\af13\dbch\f13 \'d3\'d0\'d0\'a9\'cf\'b5\'cd\'b3\'ce\'aa}{
\cf6\hich\af13\insrsid15094660\charrsid15094660 \hich\af13\dbch\af13\loch\f13 3}{\cf6\hich\af13\insrsid3831200 \hich\af13\dbch\af13\loch\f13 ,}{\cf6\hich\af13\insrsid3831200 \loch\af13\hich\af13\dbch\f13 \'bd\'f8\'b3\'cc\'d2\'d1\'be\'ad\'bd\'e1\'ca\'f8
\'d6\'b4\'d0\'d0}{\cf6\hich\af13\insrsid3831200 \hich\af13\dbch\af13\loch\f13 ,}{\cf6\hich\af13\insrsid3831200 \loch\af13\hich\af13\dbch\f13 \'b5\'ab\'c9\'d0\'ce\'b4\'cf\'fb\'cd\'f6}{\hich\af13\insrsid10314595\charrsid10314595 
\par }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 #define TASK_STOPPED\tab \tab 8}{\hich\af13\insrsid15094660 \hich\af13\dbch\af13\loch\f13  }{\cf6\hich\af13\insrsid15094660\charrsid15094660 \loch\af13\hich\af13\dbch\f13 \'d4\'dd
\'cd\'a3\'cc\'ac}{\cf6\hich\af13\insrsid15094660\charrsid15094660 \hich\af13\dbch\af13\loch\f13 ,}{\cf6\hich\af13\insrsid15094660\charrsid15094660 \loch\af13\hich\af13\dbch\f13 \'d3\'d0\'d0\'a9\'cf\'b5\'cd\'b3\'ce\'aa}{
\cf6\hich\af13\insrsid15094660\charrsid15094660 \hich\af13\dbch\af13\loch\f13 4}{\cf6\hich\af13\insrsid1257417 \hich\af13\dbch\af13\loch\f13 ,}{\cf6\hich\af13\insrsid1257417 \loch\af13\hich\af13\dbch\f13 \'d3\'c3\'c6\'e4\'cb\'fb\'bd\'f8\'b3\'cc\'b5\'c4
\'d0\'c5\'ba\'c5\'b2\'c5\'c4\'dc\'bb\'bd\'d0\'d1}{\hich\af13\insrsid10314595\charrsid10314595 
\par 
\par }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 #define __set_task_state(tsk, state_value)\tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 do \{ (tsk)->state = (state_value); \} while (0)
\par \hich\af13\dbch\af13\loch\f13 #ifdef CONFIG_SMP
\par \hich\af13\dbch\af13\loch\f13 #define set_task_state(tsk, state_value)\tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 set_mb((tsk)->state, (state_value))
\par \hich\af13\dbch\af13\loch\f13 #else
\par \hich\af13\dbch\af13\loch\f13 #define set_task_state(tsk, state_value)\tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 __set_task_state((tsk), (state_value))
\par \hich\af13\dbch\af13\loch\f13 #endif
\par 
\par \hich\af13\dbch\af13\loch\f13 #define __set_current_state(state_value)\tab \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 do \{ current->state = (state_value); \} while (0)
\par \hich\af13\dbch\af13\loch\f13 #ifdef CONFIG_SMP
\par \hich\af13\dbch\af13\loch\f13 #define set_current_state(state_value)\tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 set_mb(current->state, (state_value))
\par \hich\af13\dbch\af13\loch\f13 #else
\par \hich\af13\dbch\af13\loch\f13 #define s\hich\af13\dbch\af13\loch\f13 et_current_state(state_value)\tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 __set_current_state(state_value)
\par \hich\af13\dbch\af13\loch\f13 #endif
\par 
\par \hich\af13\dbch\af13\loch\f13 /*
\par \hich\af13\dbch\af13\loch\f13  * Scheduling policies
\par \hich\af13\dbch\af13\loch\f13  */
\par \hich\af13\dbch\af13\loch\f13 #define SCHED_OTHER\tab \tab 0}{\hich\af13\insrsid2558391 \hich\af13\dbch\af13\loch\f13   }{\cf6\hich\af13\insrsid2558391\charrsid5780670 \hich\af13\dbch\af13\loch\f13 /*}{\cf6\hich\af13\insrsid2558391\charrsid5780670 
\loch\af13\hich\af13\dbch\f13 \'c6\'d5\'cd\'a8\'bd\'f8\'b3\'cc\'b5\'c4\'ca\'b1\'bc\'e4\'c6\'ac\'c2\'d6\'d7\'aa\'cb\'e3\'b7\'a8}{\cf6\hich\af13\insrsid9056743 \hich\af13\dbch\af13\loch\f13 ,}{\cf6\hich\af13\insrsid9056743 \loch\af13\hich\af13\dbch\f13 
\'bb\'f9\loch\af13\hich\af13\dbch\f13 \'d3\'da\loch\af13\hich\af13\dbch\f13 \'d3\'c5\loch\af13\hich\af13\dbch\f13 \'cf\'c8\loch\af13\hich\af13\dbch\f13 \'bc\'b6\loch\af13\hich\af13\dbch\f13 \'b5\'c4\loch\af13\hich\af13\dbch\f13 \'c2\'d6
\loch\af13\hich\af13\dbch\f13 \'d7\'aa\loch\af13\hich\af13\dbch\f13 \'ca\'b5\loch\af13\hich\af13\dbch\f13 \'ca\'b1\loch\af13\hich\af13\dbch\f13 \'b5\'f7\loch\af13\hich\af13\dbch\f13 \'b6\'c8\loch\af13\hich\af13\dbch\f13 \'b7\'bd\'b7\'a8}{
\cf6\hich\af13\insrsid2558391\charrsid5780670 \hich\af13\dbch\af13\loch\f13 */}{\hich\af13\insrsid10314595\charrsid10314595 
\par }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 #define SCHED_FIFO\tab \tab 1}{\hich\af13\insrsid2558391 \hich\af13\dbch\af13\loch\f13  }{\cf6\hich\af13\insrsid2558391\charrsid5780670 \hich\af13\dbch\af13\loch\f13 /*}{
\cf6\hich\af13\insrsid2558391\charrsid5780670 \loch\af13\hich\af13\dbch\f13 \'ca\'b5\'ca\'b1\'bd\'f8\'b3\'cc\'b5\'c4\'cf\'c8\'bd\'f8\'cf\'c8\'b3\'f6\'cb\'e3\'b7\'a8}{\cf6\hich\af13\insrsid2558391\charrsid5780670 \hich\af13\dbch\af13\loch\f13 */}{
\cf6\hich\af13\insrsid10314595\charrsid5780670 
\par }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 #define SCHED_RR\tab \tab 2}{\hich\af13\insrsid2558391 \hich\af13\dbch\af13\loch\f13  }{\cf6\hich\af13\insrsid2558391\charrsid5780670 \hich\af13\dbch\af13\loch\f13 /*}{
\cf6\hich\af13\insrsid2558391\charrsid5780670 \loch\af13\hich\af13\dbch\f13 \'ca\'b5\'ca\'b1\'bd\'f8\'b3\'cc\'b5\'c4\'ca\'b1\'bc\'e4\'c6\'ac\'c2\'d6\'d7\'aa\'cb\'e3\'b7\'a8}{\cf6\hich\af13\insrsid13519943 \hich\af13\dbch\af13\loch\f13 ,}{
\cf6\hich\af13\insrsid13519943 \loch\af13\hich\af13\dbch\f13 \'bb\'f9\loch\af13\hich\af13\dbch\f13 \'d3\'da\loch\af13\hich\af13\dbch\f13 \'d3\'c5\loch\af13\hich\af13\dbch\f13 \'cf\'c8\loch\af13\hich\af13\dbch\f13 \'bc\'b6\loch\af13\hich\af13\dbch\f13 
\'b5\'c4\loch\af13\hich\af13\dbch\f13 \'c2\'d6\loch\af13\hich\af13\dbch\f13 \'d7\'aa\loch\af13\hich\af13\dbch\f13 \'ca\'b5\loch\af13\hich\af13\dbch\f13 \'ca\'b1\loch\af13\hich\af13\dbch\f13 \'b5\'f7\loch\af13\hich\af13\dbch\f13 \'b6\'c8
\loch\af13\hich\af13\dbch\f13 \'b7\'bd\'b7\'a8}{\cf6\hich\af13\insrsid2558391\charrsid5780670 \hich\af13\dbch\af13\loch\f13 */}{\hich\af13\insrsid10314595\charrsid10314595 
\par 
\par }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 /*
\par \hich\af13\dbch\af13\loch\f13  * This is an additional bit se\hich\af13\dbch\af13\loch\f13 t when we want to
\par \hich\af13\dbch\af13\loch\f13  * yield the CPU for one re-schedule..
\par \hich\af13\dbch\af13\loch\f13  */
\par \hich\af13\dbch\af13\loch\f13 #define SCHED_YIELD\tab \tab 0x10
\par 
\par \hich\af13\dbch\af13\loch\f13 struct sched_param \{
\par \tab \hich\af13\dbch\af13\loch\f13 int sched_priority;
\par \}\hich\af13\dbch\af13\loch\f13 ;
\par 
\par \hich\af13\dbch\af13\loch\f13 #ifdef __KERNEL__
\par 
\par \hich\af13\dbch\af13\loch\f13 #include <linux/spinlock.h>
\par 
\par \hich\af13\dbch\af13\loch\f13 /*
\par \hich\af13\dbch\af13\loch\f13  * This serializes "schedule()" and also protects
\par \hich\af13\dbch\af13\loch\f13  * the run-queue from deletions/modifications (but
\par \hich\af13\dbch\af13\loch\f13  * _adding_ to the beginning of the run-queue has
\par \hich\af13\dbch\af13\loch\f13  * a separate lock).
\par \hich\af13\dbch\af13\loch\f13  */
\par \hich\af13\dbch\af13\loch\f13 extern rwlock_t tasklist_lock;
\par \hich\af13\dbch\af13\loch\f13 extern spinlock_t runqueue_lock;
\par \hich\af13\dbch\af13\loch\f13 extern spinlock_t mmlist_lock;
\par 
\par \hich\af13\dbch\af13\loch\f13 extern void sched_init(void);
\par \hich\af13\dbch\af13\loch\f13 exte\hich\af13\dbch\af13\loch\f13 rn void init_idle(void);
\par \hich\af13\dbch\af13\loch\f13 extern void show_state(void);
\par \hich\af13\dbch\af13\loch\f13 extern void cpu_init (void);
\par \hich\af13\dbch\af13\loch\f13 extern void trap_init(void);
\par \hich\af13\dbch\af13\loch\f13 extern void update_process_times(int user);
\par \hich\af13\dbch\af13\loch\f13 extern void update_one_process(struct task_struct *p, unsigned long user,
\par \tab \tab \tab \hich\af13\dbch\af13\loch\f13        unsigned long s\hich\af13\dbch\af13\loch\f13 ystem, int cpu);
\par 
\par \hich\af13\dbch\af13\loch\f13 #define\tab MAX_SCHEDULE_TIMEOUT\tab LONG_MAX
\par \hich\af13\dbch\af13\loch\f13 extern signed long FASTCALL(schedule_timeout(signed long timeout));
\par \hich\af13\dbch\af13\loch\f13 asmlinkage void schedule(void);
\par 
\par \hich\af13\dbch\af13\loch\f13 extern int schedule_task(struct tq_struct *task);
\par \hich\af13\dbch\af13\loch\f13 extern void flush_scheduled_tasks(void);
\par \hich\af13\dbch\af13\loch\f13 extern int start_context_thread(void);
\par \hich\af13\dbch\af13\loch\f13 extern int current_is_keventd(void);
\par 
\par \hich\af13\dbch\af13\loch\f13 /*
\par \hich\af13\dbch\af13\loch\f13  * The default fd array needs to be at least BITS_PER_LONG,
\par \hich\af13\dbch\af13\loch\f13  * as this is the granularity returned by copy_fdset().
\par \hich\af13\dbch\af13\loch\f13  */
\par \hich\af13\dbch\af13\loch\f13 #define NR_OPEN_DEFAULT BITS_PER_LONG
\par 
\par \hich\af13\dbch\af13\loch\f13 /*
\par \hich\af13\dbch\af13\loch\f13  * Open file t\hich\af13\dbch\af13\loch\f13 able structure
\par \hich\af13\dbch\af13\loch\f13  */
\par \hich\af13\dbch\af13\loch\f13 struct files_struct \{}{\cf6\hich\af13\insrsid7610296\charrsid7610296 \hich\af13\dbch\af13\loch\f13 /*}{\cf6\hich\af13\insrsid7610296\charrsid7610296 \loch\af13\hich\af13\dbch\f13 \'b0\'fc\'ba\'ac\'bd\'f8\'b3\'cc\'b5\'c4
\'b4\'f2\'bf\'aa\'ce\'c4\'bc\'fe\'b1\'ed}{\cf6\hich\af13\insrsid11556185 \hich\af13\dbch\af13\loch\f13 ,}{\cf6\hich\af13\insrsid11556185 \loch\af13\hich\af13\dbch\f13 \'c4\'b3\'bd\'f8\'b3\'cc\'b4\'f2\'bf\'aa\'b5\'c4\'cb\'f9\'d3\'d0\'ce\'c4\'bc\'fe}{
\cf6\hich\af13\insrsid4471939 \hich\af13\dbch\af13\loch\f13 ,}{\insrsid4471939\charrsid4471939 \hich\af2\dbch\af13\loch\f13  }{\cf6\hich\af13\insrsid4471939\charrsid4471939 \loch\af13\hich\af13\dbch\f13 \'bd\'f8\'b3\'cc\'b5\'b1\'c7\'b0\'cb\'f9\'b4\'f2
\'bf\'aa\'b5\'c4\'cb\'f9\'d3\'d0\'ce\'c4\'bc\'fe\'d0\'c5\'cf\'a2}{\cf6\hich\af13\insrsid7610296\charrsid7610296 \hich\af13\dbch\af13\loch\f13 */}{\cf6\hich\af13\insrsid10314595\charrsid7610296 
\par }{\hich\af13\insrsid10314595\charrsid10314595 \tab }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 atomic_t count;}{\cf6\hich\af13\insrsid12806999\charrsid12806999 \hich\af13\dbch\af13\loch\f13 /*}{
\cf6\hich\af13\insrsid12806999\charrsid12806999 \loch\af13\hich\af13\dbch\f13 \'b9\'b2\'cf\'ed\'b8\'c3\'bd\'e1\'b9\'b9\'b5\'c4\'bc\'c6\'ca\'fd\'d6\'b5}{\cf6\hich\af13\insrsid12806999\charrsid12806999 \hich\af13\dbch\af13\loch\f13 */}{
\cf6\hich\af13\insrsid10314595\charrsid12806999 
\par }{\hich\af13\insrsid10314595\charrsid10314595 \tab }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 rwlock_t file_lock;
\par \tab \hich\af13\dbch\af13\loch\f13 int max_fds;
\par \tab \hich\af13\dbch\af13\loch\f13 int max_fdset;
\par \tab \hich\af13\dbch\af13\loch\f13 int next_fd;
\par \tab \hich\af13\dbch\af13\loch\f13 struct file ** fd;\tab /* current fd array */
\par \tab \hich\af13\dbch\af13\loch\f13 fd_set *close_on_exec;
\par \tab \hich\af13\dbch\af13\loch\f13 fd_set *open_fds;
\par \tab \hich\af13\dbch\af13\loch\f13 fd_set close_on_exec_init;
\par \tab \hich\af13\dbch\af13\loch\f13 fd_set open_fds_init;
\par \tab \hich\af13\dbch\af13\loch\f13 struct file * fd_array[NR_OPEN_DEFAULT];}{\cf6\hich\af13\insrsid12806999\charrsid12806999 \hich\af13\dbch\af13\loch\f13 /*}{\cf6\hich\af13\insrsid12806999\charrsid12806999 \loch\af13\hich\af13\dbch\f13 \'bd\'f8\'b3\'cc
\'b4\'f2\'bf\'aa\'ce\'c4\'bc\'fe\'b1\'ed}{\cf6\hich\af13\insrsid12806999\charrsid12806999 \hich\af13\dbch\af13\loch\f13 */}{\hich\af13\insrsid10314595\charrsid10314595 
\par \}}{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 ;
\par 
\par \hich\af13\dbch\af13\loch\f13 #define INIT_FILES \\
\par \{\hich\af13\dbch\af13\loch\f13  \tab \tab \tab \tab \tab \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 count:\tab \tab ATOMIC_INIT(1), \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 file_lock:\tab RW_LOCK_UNLOCKED, \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 max_fds:\tab NR_OPEN_DEFAULT, \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 max_fdset:\tab __FD_SETSIZE, \tab \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 next_fd:\tab 0, \tab \tab \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 fd:\tab \tab &init_files.fd_array[0], \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 close_on_exec:\tab &init_files.close_on_exec_init, \\
\par \tab \hich\af13\dbch\af13\loch\f13 open_fds:\tab &init_files.open_fds_init, \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 close_on_exec_init: \{ \{ 0, \} \}, \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 open_fds_init:\tab \{ \{ 0, \} \}, \tab \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 fd_array:\tab \{\hich\af13\dbch\af13\loch\f13  NULL, \} \tab \tab \tab \\
\par \}
\par 
\par \hich\af13\dbch\af13\loch\f13 /* Maximum number of active map areas.. This is a random (large) number */
\par \hich\af13\dbch\af13\loch\f13 #define MAX_MAP_COUNT\tab (65536)
\par 
\par \hich\af13\dbch\af13\loch\f13 /* Number of map areas at which the AVL tree is activated. This is arbitrary. */
\par \hich\af13\dbch\af13\loch\f13 #define AVL_MIN_MAP_COUNT\tab 32
\par 
\par \hich\af13\dbch\af13\loch\f13 struct mm_struct \{}{\cf6\hich\af13\insrsid1114342\charrsid1114342 \hich\af13\dbch\af13\loch\f13 /*}{\cf6\hich\af13\insrsid1114342\charrsid1114342 \loch\af13\hich\af13\dbch\f13 \'c3\'e8\'ca\'f6\loch\af13\hich\af13\dbch\f13 
\'d0\'e9\'c4\'e2\'c4\'da\'b4\'e6\'b5\'c4\'d3\'c3\'bb\'a7\'c7\'f8}{\cf6\hich\af13\insrsid1114342\charrsid1114342 \hich\af13\dbch\af13\loch\f13 ,}{\cf6\hich\af13\insrsid1114342\charrsid1114342 \loch\af13\hich\af13\dbch\f13 \'bc\'c7\'c2\'bc\'d3\'c3\'bb\'a7
\'c7\'f8\'c4\'da\'b4\'fa\'c2\'eb\'b6\'ce\'ba\'cd\'ca\'fd\'be\'dd\'b6\'ce\'ba\'cd\'d3\'d0\'b9\'d8\'ca\'fd\'be\'dd\'bd\'e1\'b9\'b9\'cb\'f9\'d4\'da\'ce\'bb\'d6\'c3\'bc\'b0\'d0\'e9\'c4\'e2\'c4\'da\'b4\'e6\'b5\'c4\'c6\'e4\'cb\'fc\'ca\'f4\'d0\'d4}{
\cf6\hich\af13\insrsid19142 \hich\af13\dbch\af13\loch\f13 ,}{\cf6\hich\af13\insrsid19142 \loch\af13\hich\af13\dbch\f13 \'c3\'e8\'ca\'f6\'c4\'b3\'c8\'ce\'ce\'f1\'bb\'f2\'bd\'f8\'b3\'cc\'b5\'c4\'d0\'e9\'c4\'e2\'c4\'da\'b4\'e6}{\cf6\hich\af13\insrsid19142 
\hich\af13\dbch\af13\loch\f13 ,}{\cf6\hich\af13\insrsid19142 \loch\af13\hich\af13\dbch\f13 \'cb\'fc\'b5\'c4\'ca\'b9\'d3\'c3\'c6\'b5\'b6\'c8\'bd\'cf\'b8\'df}{\cf6\hich\af13\insrsid19142 \hich\af13\dbch\af13\loch\f13 .}{\cf6\hich\af13\insrsid19142 
\loch\af13\hich\af13\dbch\f13 \'c3\'bf\'b8\'f6\'bd\'f8\'b3\'cc\'b5\'c4\'d0\'e9\'c4\'e2\'c4\'da\'b4\'e6\'b6\'bc\'d3\'c9\'d2\'bb\'b8\'f6}{\cf6\hich\af13\insrsid19142 \hich\af13\dbch\af13\loch\f13 mm_struct}{\cf6\hich\af13\insrsid19142 
\loch\af13\hich\af13\dbch\f13 \'bd\'e1\'b9\'b9\'b4\'fa\'b1\'ed}{\cf6\hich\af13\insrsid19142 \hich\af13\dbch\af13\loch\f13 ,}{\cf6\hich\af13\insrsid19142 \loch\af13\hich\af13\dbch\f13 \'b8\'c3\'bd\'e1\'b9\'b9\'ca\'b5\'bc\'ca\'b0\'fc\'ba\'ac\'b5\'b1\'c7\'b0
\'d6\'b4\'d0\'d0\'d3\'b3\'cf\'f1\'b5\'c4\'d3\'d0\'b9\'d8\'d0\'c5\'cf\'a2}{\cf6\hich\af13\insrsid19142 \hich\af13\dbch\af13\loch\f13 ,}{\cf6\hich\af13\insrsid19142 \loch\af13\hich\af13\dbch\f13 \'c7\'d2\'b0\'fc\'ba\'ac\'d2\'bb\'d7\'e9\'d6\'b8\'cf\'f2}{
\cf6\hich\af13\insrsid19142 \hich\af13\dbch\af13\loch\f13 vm_area_struct}{\cf6\hich\af13\insrsid19142 \loch\af13\hich\af13\dbch\f13 \'bd\'e1\'b9\'b9\'b5\'c4\'d6\'b8\'d5\'eb}{\cf6\hich\af13\insrsid1114342\charrsid1114342 \hich\af13\dbch\af13\loch\f13 *}{
\hich\af13\insrsid1114342 \hich\af13\dbch\af13\loch\f13 /}{\hich\af13\insrsid10314595\charrsid10314595 
\par \tab }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 struct vm_area_struct * mmap;\tab \tab /* list of VMAs }{\cf6\hich\af13\insrsid6314868\charrsid6314868 \loch\af13\hich\af13\dbch\f13 \'d6\'b8\'cf\'f2\'d0\'e9\'b4\'e6\'c7\'f8
\'d3\'f2}{\cf6\hich\af13\insrsid6314868\charrsid6314868 \hich\af13\dbch\af13\loch\f13 vm_area_struct}{\cf6\hich\af13\insrsid6314868\charrsid6314868 \loch\af13\hich\af13\dbch\f13 \'bd\'e1\'b9\'b9\'cc\'e5\'c1\'b4\'bd\'d3\'b5\'a5\'cf\'f2\'c1\'b4\'c7\'d2
\'b5\'c4\'ca\'d7\'b5\'d8\'d6\'b7}{\cf6\hich\af13\insrsid10314595\charrsid6314868 \hich\af13\dbch\af13\loch\f13 */
\par }{\hich\af13\insrsid10314595\charrsid10314595 \tab }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 struct vm_area_struct * mmap_avl;\tab /* tree of VMAs */
\par \tab \hich\af13\dbch\af13\loch\f13 struct vm_area_struct * mmap_cache;\tab /* last find_vma result */
\par \tab \hich\af13\dbch\af13\loch\f13 pgd_t * pgd;}{\hich\af13\insrsid4353300 \hich\af13\dbch\af13\loch\f13 /}{\cf6\hich\af13\insrsid4353300\charrsid4353300 \hich\af13\dbch\af13\loch\f13 *}{\cf6\hich\af13\insrsid4353300\charrsid4353300 
\loch\af13\hich\af13\dbch\f13 \'d6\'b8\'cf\'f2\'bd\'f8\'b3\'cc\'d2\'b3\'c4\'bf\'c2\'bc\'b1\'ed\'b5\'c4\'d6\'b8\'d5\'eb}{\cf6\hich\af13\insrsid4353300\charrsid4353300 \hich\af13\dbch\af13\loch\f13 *}{\hich\af13\insrsid4353300 \hich\af13\dbch\af13\loch\f13 
/}{\hich\af13\insrsid10314595\charrsid10314595 
\par \tab }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 atomic_t mm_users;\tab \tab \tab /* How many users with user space? */
\par \tab \hich\af13\dbch\af13\loch\f13 atomic_t mm_count;\tab \tab \tab /* How many references to "\hich\af13\dbch\af13\loch\f13 struct mm_struct" (users count as 1) }{\cf6\hich\af13\insrsid9062547\charrsid9062547 \loch\af13\hich\af13\dbch\f13 \'b9\'b2
\'cf\'ed\'b4\'cb\'d0\'e9\'c4\'e2\'c4\'da\'b4\'e6\'b5\'c4\'bd\'f8\'b3\'cc\'bc\'c6\'ca\'fd}{\cf6\hich\af13\insrsid10314595\charrsid9062547 \hich\af13\dbch\af13\loch\f13 */}{\hich\af13\insrsid10314595\charrsid10314595 
\par \tab }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 int map_count;\tab \tab \tab \tab /* number of VMAs */
\par \tab \hich\af13\dbch\af13\loch\f13 struct semaphore mmap_sem;
\par \tab \hich\af13\dbch\af13\loch\f13 spinlock_t page_table_lock;
\par 
\par \tab \hich\af13\dbch\af13\loch\f13 struct list_head mmlist;\tab \tab /* List of all active mm's */
\par 
\par \tab \hich\af13\dbch\af13\loch\f13 unsigned long start_code, end_code, start_data,\hich\af13\dbch\af13\loch\f13  end_data;}{\hich\af13\insrsid14501447\charrsid14501447 \hich\af13\dbch\af13\loch\f13  }{\cf6\hich\af13\insrsid14501447\charrsid14501447 
\hich\af13\dbch\af13\loch\f13 /*start_code}{\cf6\hich\af13\insrsid14501447\charrsid14501447 \loch\af13\hich\af13\dbch\f13 \'b4\'fa\'c2\'eb\'b6\'ce\'ca\'d7\'b5\'d8\'d6\'b7}{\cf6\hich\af13\insrsid14501447\charrsid14501447 \hich\af13\dbch\af13\loch\f13 
, end_code}{\cf6\hich\af13\insrsid14501447\charrsid14501447 \loch\af13\hich\af13\dbch\f13 \'b4\'fa\'c2\'eb\'b6\'ce\'d6\'d5\'d6\'b9\'b5\'d8\'d6\'b7}{\cf6\hich\af13\insrsid14501447\charrsid14501447 \hich\af13\dbch\af13\loch\f13 , start_data}{
\cf6\hich\af13\insrsid14501447\charrsid14501447 \loch\af13\hich\af13\dbch\f13 \'ca\'fd\'be\'dd\'b6\'ce\'ca\'d7\'b5\'d8\'d6\'b7}{\cf6\hich\af13\insrsid14501447\charrsid14501447 \hich\af13\dbch\af13\loch\f13 , end_data}{
\cf6\hich\af13\insrsid14501447\charrsid14501447 \loch\af13\hich\af13\dbch\f13 \'ca\'fd\'be\'dd\'b6\'ce\'d6\'d5\'d6\'b9\'b5\'d8\'d6\'b7}{\cf6\hich\af13\insrsid14501447\charrsid14501447 \hich\af13\dbch\af13\loch\f13 */}{
\cf6\hich\af13\insrsid10314595\charrsid14501447 
\par }{\hich\af13\insrsid10314595\charrsid10314595 \tab }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 unsigned long start_brk, brk, start_stack;}{\hich\af13\insrsid13308640 \hich\af13\dbch\af13\loch\f13 /*}{
\hich\af13\insrsid13308640\charrsid13308640 \hich\af13\dbch\af13\loch\f13  }{\cf6\hich\af13\insrsid13308640\charrsid13308640 \hich\af13\dbch\af13\loch\f13 start_stack }{\cf6\hich\af13\insrsid13308640\charrsid13308640 \loch\af13\hich\af13\dbch\f13 \'bd\'f8
\'b3\'cc\'b6\'d1\'d5\'bb\'b5\'c4\'ca\'d7\'b5\'d8\'d6\'b7}{\cf6\hich\af13\insrsid13308640\charrsid13308640 \hich\af13\dbch\af13\loch\f13 */}{\hich\af13\insrsid10314595\charrsid10314595 
\par \tab }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 unsigned long arg_start, arg_end, env_start, env_end;}{\hich\af13\insrsid2181323 \hich\af13\dbch\af13\loch\f13 /}{\cf6\hich\af13\insrsid2181323\charrsid12538393 
\hich\af13\dbch\af13\loch\f13 * arg_start}{\cf6\hich\af13\insrsid2181323\charrsid12538393 \loch\af13\hich\af13\dbch\f13 \'b2\'ce\'ca\'fd\'c7\'f8\'ca\'d7\'b5\'d8\'d6\'b7}{\cf6\hich\af13\insrsid2181323\charrsid12538393 \hich\af13\dbch\af13\loch\f13 
, arg_end}{\cf6\hich\af13\insrsid2181323\charrsid12538393 \loch\af13\hich\af13\dbch\f13 \'b2\'ce\'ca\'fd\'c7\'f8\'d6\'d5\'d6\'b9\'b5\'d8\'d6\'b7}{\cf6\hich\af13\insrsid2181323\charrsid12538393 \hich\af13\dbch\af13\loch\f13 , env_start}{
\cf6\hich\af13\insrsid2181323\charrsid12538393 \loch\af13\hich\af13\dbch\f13 \'bb\'b7\'be\'b3\'b1\'e4\'c1\'bf\loch\af13\hich\af13\dbch\f13 \'c7\'f8\'b5\'c4\'ca\'d7\'b5\'d8\'d6\'b7}{\cf6\hich\af13\insrsid2181323\charrsid12538393 
\hich\af13\dbch\af13\loch\f13 , env_end}{\cf6\hich\af13\insrsid2181323\charrsid12538393 \loch\af13\hich\af13\dbch\f13 \'bb\'b7\'be\'b3\'b1\'e4\'c1\'bf\'c7\'f8\'b5\'c4\'d6\'d5\'d6\'b9\'b5\'d8\'d6\'b7}{\cf6\hich\af13\insrsid2181323\charrsid12538393 
\hich\af13\dbch\af13\loch\f13 */}{\cf6\hich\af13\insrsid10314595\charrsid12538393 
\par }{\hich\af13\insrsid10314595\charrsid10314595 \tab }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 unsigned long rss, total_vm, locked_vm;}{\hich\af13\insrsid10225817 \hich\af13\dbch\af13\loch\f13 /}{
\cf6\hich\af13\insrsid10225817\charrsid10225817 \hich\af13\dbch\af13\loch\f13 * total_vm }{\cf6\hich\af13\insrsid10225817\charrsid10225817 \loch\af13\hich\af13\dbch\f13 \'bd\'f8\'b3\'cc\'d5\'bc\'d3\'c3\'d0\'e9\'c4\'e2\'b5\'c4\'d7\'dc\'c8\'dd\'c1\'bf}{
\cf6\hich\af13\insrsid10225817\charrsid10225817 \hich\af13\dbch\af13\loch\f13 *}{\hich\af13\insrsid10225817 \hich\af13\dbch\af13\loch\f13 /}{\hich\af13\insrsid10314595\charrsid10314595 
\par \tab }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 unsigned long def_flags;
\par \tab \hich\af13\dbch\af13\loch\f13 unsigned long cpu_vm_mask;
\par \tab \hich\af13\dbch\af13\loch\f13 unsigned long swap_cnt;\tab /* number of pages to swap on next pass */
\par \tab \hich\af13\dbch\af13\loch\f13 unsigned long swap_address;
\par 
\par \tab \hich\af13\dbch\af13\loch\f13 /* Architecture-specific MM context */
\par \tab \hich\af13\dbch\af13\loch\f13 mm_context_t context;}{\cf6\hich\af13\insrsid16268027\charrsid16268027 \hich\af13\dbch\af13\loch\f13 /*}{\cf6\hich\af13\insrsid16268027\charrsid16268027 \loch\af13\hich\af13\dbch\f13 \'bd\'f8\'b3\'cc\'c9\'cf\'cf\'c2
\'ce\'c4\'b5\'c4\'b5\'d8\'d6\'b7}{\cf6\hich\af13\insrsid16268027\charrsid16268027 \hich\af13\dbch\af13\loch\f13 */}{\hich\af13\insrsid10314595\charrsid10314595 
\par \}}{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 ;
\par 
\par \hich\af13\dbch\af13\loch\f13 #define INIT_MM(name) \\
\par \{\tab \tab \tab \hich\af13\dbch\af13\loch\f13  \tab \tab \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 mmap:\tab \tab &init_mmap, \tab \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 mmap_avl:\tab NULL, \tab \tab \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 mmap_cache:\tab NULL, \tab \tab \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 pgd:\tab \tab swapper_pg_dir, \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 mm_users:\tab ATOMIC_INIT(2), \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 mm_count:\tab \hich\af13\dbch\af13\loch\f13 ATOMIC_INIT(1), \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 map_count:\tab 1, \tab \tab \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 mmap_sem:\tab __MUTEX_INITIALIZER(name.mmap_sem), \\
\par \tab \hich\af13\dbch\af13\loch\f13 page_table_lock: SPIN_LOCK_UNLOCKED, \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 mmlist:\tab \tab LIST_HEAD_INIT(name.mmlist),\tab \\
\par \}
\par 
\par \hich\af13\dbch\af13\loch\f13 struct signal_struct \{}{\cf6\hich\af13\insrsid14168890\charrsid721367 \hich\af13\dbch\af13\loch\f13 /*}{\cf6\hich\af13\insrsid14168890\charrsid721367 \loch\af13\hich\af13\dbch\f13 \'b9\'dc\'c0\'ed\'bd\'f8\'b3\'cc\'b6\'d4
\'cb\'f9\'d3\'d0\'d0\'c5\'ba\'c5\'b4\'a6\'c0\'ed\'ba\'af\'ca\'fd\'bc\'af}{\cf6\hich\af13\insrsid14168890\charrsid721367 \hich\af13\dbch\af13\loch\f13 */}{\hich\af13\insrsid10314595\charrsid10314595 
\par \tab }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 atomic_t\tab \tab count;}{\hich\af13\insrsid721367 \hich\af13\dbch\af13\loch\f13 /}{\cf6\hich\af13\insrsid721367\charrsid9266659 \hich\af13\dbch\af13\loch\f13 *}{
\cf6\hich\af13\insrsid721367\charrsid9266659 \loch\af13\hich\af13\dbch\f13 \'b9\'b2\'cf\'ed\'d0\'c5\'ba\'c5\'b4\'a6\'c0\'ed\'ba\'af\'ca\'fd\'b5\'c4\'bc\'c6\'ca\'fd\'d6\'b5}{\cf6\hich\af13\insrsid721367\charrsid9266659 \hich\af13\dbch\af13\loch\f13 ,}{
\cf6\hich\af13\insrsid721367\charrsid9266659 \loch\af13\hich\af13\dbch\f13 \'d2\'bb\'b0\'e3\'ca\'c7\'d7\'d3\'bd\'f8\'b3\'cc\'bc\'cc\loch\af13\hich\af13\dbch\f13 \'b3\'d0\'b8\'b8\'bd\'f8\'b3\'cc\'b5\'c4\'d0\'c5\'ba\'c5\'bb\'fa\'d6\'c6\'ca\'b1\'b5\'c4
\'bc\'c6\'ca\'fd\'d6\'b5}{\cf6\hich\af13\insrsid721367\charrsid9266659 \hich\af13\dbch\af13\loch\f13 ,}{\cf6\hich\af13\insrsid721367\charrsid9266659 \loch\af13\hich\af13\dbch\f13 \'d7\'d3\'bd\'f8\'b3\'cc\'d2\'aa\'bc\'cc\'b3\'d0\'b8\'b8\'bd\'f8\'b3\'cc
\'b5\'c4\'d7\'ca\'d4\'b4}{\cf6\hich\af13\insrsid721367\charrsid9266659 \hich\af13\dbch\af13\loch\f13 ,}{\cf6\hich\af13\insrsid721367\charrsid9266659 \loch\af13\hich\af13\dbch\f13 \'b0\'fc\'c0\'a8\'b8\'b8\'bd\'f8\'b3\'cc\'b5\'c4\'d0\'c5\'ba\'c5\'b4\'a6
\'c0\'ed\'ba\'af\'ca\'fd}{\cf6\hich\af13\insrsid721367\charrsid9266659 \hich\af13\dbch\af13\loch\f13 ,}{\cf6\hich\af13\insrsid721367\charrsid9266659 \loch\af13\hich\af13\dbch\f13 \'d5\'e2\'ca\'b1\'b8\'b8\'bd\'f8\'b3\'cc\'c8\'ce\'ce\'f1\'bd\'e1\'b9\'b9
\'cc\'e5\'b5\'c4}{\cf6\hich\af13\insrsid721367\charrsid9266659 \hich\af13\dbch\af13\loch\f13 sig->count\~}{\cf6\hich\af13\insrsid721367\charrsid9266659 \loch\af13\hich\af13\dbch\f13 \'bc\'d3}{\cf6\hich\af13\insrsid721367\charrsid9266659 
\hich\af13\dbch\af13\loch\f13 1*/}{\hich\af13\insrsid10314595\charrsid10314595 
\par \tab }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 struct k_sigaction\tab action[_NSIG];}{\hich\af13\insrsid9266659 \hich\af13\dbch\af13\loch\f13 /}{\cf6\hich\af13\insrsid9266659\charrsid9266659 \hich\af13\dbch\af13\loch\f13 
*}{\cf6\hich\af13\insrsid9266659\charrsid9266659 \loch\af13\hich\af13\dbch\f13 \'bd\'f8\'b3\'cc\'b5\'c4\'d0\'c5\'ba\'c5\'b4\'a6\'c0\'ed\'ba\'af\'ca\'fd\'b1\'ed}{\cf6\hich\af13\insrsid9266659\charrsid9266659 \hich\af13\dbch\af13\loch\f13 ,}{
\cf6\hich\af13\insrsid9266659\charrsid9266659 \loch\af13\hich\af13\dbch\f13 \'b6\'d4\'d3\'a6\'d0\'c5\'ba\'c5}{\cf6\hich\af13\insrsid9266659\charrsid9266659 \hich\af13\dbch\af13\loch\f13 , k_sigaction }{\cf6\hich\af13\insrsid9266659\charrsid9266659 
\loch\af13\hich\af13\dbch\f13 \'d4\'da}{\cf6\hich\af13\insrsid9266659\charrsid9266659 \hich\af13\dbch\af13\loch\f13 /asm-i386/signal.h}{\cf6\hich\af13\insrsid9266659\charrsid9266659 \loch\af13\hich\af13\dbch\f13 \'d6\'d0\'b6\'a8\'d2\'e5}{
\cf6\hich\af13\insrsid9266659\charrsid9266659 \hich\af13\dbch\af13\loch\f13 */}{\hich\af13\insrsid10314595\charrsid10314595 
\par \tab }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 spinlock_t\tab \tab siglock;
\par \}\hich\af13\dbch\af13\loch\f13 ;
\par 
\par 
\par \hich\af13\dbch\af13\loch\f13 #define INIT_SIGNALS \{\tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 count:\tab \tab ATOMIC_INIT(1), \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 action:\tab \tab \{ \{\{0,\}\}\hich\af13\dbch\af13\loch\f13 , \}, \tab \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 siglock:\tab SPIN_LOCK_UNLOCKED \tab \tab \\
\par \}
\par 
\par \hich\af13\dbch\af13\loch\f13 /*
\par \hich\af13\dbch\af13\loch\f13  * Some day this will be a full-fledged user tracking system..
\par \hich\af13\dbch\af13\loch\f13  */
\par \hich\af13\dbch\af13\loch\f13 struct user_struct \{
\par \tab \hich\af13\dbch\af13\loch\f13 atomic_t __count;\tab /* reference count */
\par \tab \hich\af13\dbch\af13\loch\f13 atomic_t processes;\tab /* How many processes does this user have? */
\par \tab \hich\af13\dbch\af13\loch\f13 atomic_t \hich\af13\dbch\af13\loch\f13 files;\tab \tab /* How many open files does this user have? */
\par 
\par \tab \hich\af13\dbch\af13\loch\f13 /* Hash table maintenance information */
\par \tab \hich\af13\dbch\af13\loch\f13 struct user_struct *next, **pprev;
\par \tab \hich\af13\dbch\af13\loch\f13 uid_t uid;
\par \}\hich\af13\dbch\af13\loch\f13 ;
\par 
\par \hich\af13\dbch\af13\loch\f13 #define get_current_user() (\{ \tab \tab \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 struct user_struct *__user = current->user;\tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 atomic_inc(&__user->__count);\tab \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 __user; \})
\par 
\par \hich\af13\dbch\af13\loch\f13 extern struct user_struct root_user;
\par \hich\af13\dbch\af13\loch\f13 #define INIT_USER (&root_user)
\par 
\par \hich\af13\dbch\af13\loch\f13 struct task_struct \{}{\cf6\hich\af13\insrsid16718750\charrsid16718750 \hich\af13\dbch\af13\loch\f13 //Linux}{\cf6\hich\af13\insrsid16718750\charrsid16718750 \loch\af13\hich\af13\dbch\f13 \'c4\'da\'ba\'cb\'c0\'fb\'d3\'c3
\'ca\'fd\'be\'dd\'bd\'e1\'b9\'b9}{\cf6\hich\af13\insrsid16718750\charrsid16718750 \hich\af13\dbch\af13\loch\f13 task_struct}{\cf6\hich\af13\insrsid16718750\charrsid16718750 \loch\af13\hich\af13\dbch\f13 \'c3\'e8\'ca\'f6\'cf\'b5\'cd\'b3\'d6\'d0\'b5\'c4
\'bd\'f8\'b3\'cc\'bb\'f2\'c8\'ce\'ce\'f1}{\cf6\hich\af13\insrsid16718750\charrsid16718750 \hich\af13\dbch\af13\loch\f13 .task_struct}{\cf6\hich\af13\insrsid16718750\charrsid16718750 \loch\af13\hich\af13\dbch\f13 \'ca\'b9\'d3\'c3\'c6\'b5\'b6\'c8\'bd\'cf
\'b8\'df}{\cf6\hich\af13\insrsid16718750\charrsid16718750 \hich\af13\dbch\af13\loch\f13 ,}{\cf6\hich\af13\insrsid16718750\charrsid16718750 \loch\af13\hich\af13\dbch\f13 \'cb\'fc\'b4\'fa\'b1\'ed\'d2\'bb\'b8\'f6\'bd\'f8\'b3\'cc}{
\cf6\hich\af13\insrsid16718750\charrsid16718750 \hich\af13\dbch\af13\loch\f13 ,}{\cf6\hich\af13\insrsid16718750\charrsid16718750 \loch\af13\hich\af13\dbch\f13 \'b4\'fa\'b1\'ed\'bd\'f8\'b3\'cc\'b5\'c4\'ca\'fd\'be\'dd\'bd\'e1\'b9\'b9\'d6\'b8\'d5\'eb\'d0\'ce
\'b3\'c9\'d2\'bb\'b8\'f6}{\cf6\hich\af13\insrsid16718750\charrsid16718750 \hich\af13\dbch\af13\loch\f13 task}{\cf6\hich\af13\insrsid16718750\charrsid16718750 \loch\af13\hich\af13\dbch\f13 \'ca\'fd\'d7\'e9}{\cf6\hich\af13\insrsid16718750\charrsid16718750 
\hich\af13\dbch\af13\loch\f13 ,}{\cf6\hich\af13\insrsid16718750\charrsid16718750 \loch\af13\hich\af13\dbch\f13 \'d5\'e2\'b8\'f6\'d6\'b8\'d5\'eb\'ca\'fd\'d7\'e9}{\cf6\hich\af13\insrsid16718750\charrsid16718750 \hich\af13\dbch\af13\loch\f13 (}{
\cf6\hich\af13\insrsid16718750\charrsid16718750 \loch\af13\hich\af13\dbch\f13 \'d6\'b8\'d5\'eb\'cf\'f2\'c1\'bf}{\cf6\hich\af13\insrsid16718750\charrsid16718750 \hich\af13\dbch\af13\loch\f13 )}{\cf6\hich\af13\insrsid16718750\charrsid16718750 
\loch\af13\hich\af13\dbch\f13 \'b5\'c4\'b4\'f3\'d0\'a1\'d3\'c9}{\cf6\hich\af13\insrsid16718750\charrsid16718750 \hich\af13\dbch\af13\loch\f13 NR_TASKS}{\cf6\hich\af13\insrsid16718750\charrsid16718750 \loch\af13\hich\af13\dbch\f13 \'be\'f6\'b6\'a8}{
\cf6\hich\af13\insrsid16718750\charrsid16718750 \hich\af13\dbch\af13\loch\f13 ,}{\cf6\hich\af13\insrsid16718750\charrsid16718750 \loch\af13\hich\af13\dbch\f13 \'b1\'ed\'c3\'f7}{\cf6\hich\af13\insrsid16718750\charrsid16718750 \hich\af13\dbch\af13\loch\f13 
Linux}{\cf6\hich\af13\insrsid16718750\charrsid16718750 \loch\af13\hich\af13\dbch\f13 \'cf\'b5\'cd\'b3\'d6\'d0\'d7\'ee\'b6\'e0\'c4\'dc\'cd\'ac\'ca\'b1\'d4\'cb\'d0\'d0\'b5\'c4\'bd\'f8\'b3\'cc\'ca\'fd\'c4\'bf}{\cf6\hich\af13\insrsid16718750\charrsid16718750 
\hich\af13\dbch\af13\loch\f13 .}{\cf6\hich\af13\insrsid16718750\charrsid16718750 \loch\af13\hich\af13\dbch\f13 \'b5\'b1\'bd\'a8\'c1\'a2\'d0\'c2\'bd\'f8\'b3\'cc\'b5\'c4\'ca\'b1\'ba\'f2}{\cf6\hich\af13\insrsid16718750\charrsid16718750 
\hich\af13\dbch\af13\loch\f13 ,Linux}{\cf6\hich\af13\insrsid16718750\charrsid16718750 \loch\af13\hich\af13\dbch\f13 \'ce\'aa\'d0\'c2\'bd\'f8\'b3\'cc\'b7\'d6\'c5\'e4\'d2\'bb\'b8\'f6}{\cf6\hich\af13\insrsid16718750\charrsid16718750 
\hich\af13\dbch\af13\loch\f13 task_struct}{\cf6\hich\af13\insrsid16718750\charrsid16718750 \loch\af13\hich\af13\dbch\f13 \'bd\'e1\'b9\'b9}{\cf6\hich\af13\insrsid16718750\charrsid16718750 \hich\af13\dbch\af13\loch\f13 ,}{
\cf6\hich\af13\insrsid16718750\charrsid16718750 \loch\af13\hich\af13\dbch\f13 \'c8\'bb\'ba\'f3\'bd\'ab\'d6\'b8\'d5\'eb\'b1\'a3\'b4\'e6\'d4\'da}{\cf6\hich\af13\insrsid16718750\charrsid16718750 \hich\af13\dbch\af13\loch\f13 task}{
\cf6\hich\af13\insrsid16718750\charrsid16718750 \loch\af13\hich\af13\dbch\f13 \'ca\'fd\'d7\'e9\'d6\'d0}{\cf6\hich\af13\insrsid16718750\charrsid16718750 \hich\af13\dbch\af13\loch\f13 ,}{\cf6\hich\af13\insrsid16718750\charrsid16718750 
\loch\af13\hich\af13\dbch\f13 \'b5\'f7\'b6\'c8\'b3\'cc\'d0\'f2\'d2\'bb\'d6\'b1\'ce\'ac\'bb\'a4\'d7\'c5\'d2\'bb\'b8\'f6}{\cf6\hich\af13\insrsid16718750\charrsid16718750 \hich\af13\dbch\af13\loch\f13 current}{\cf6\hich\af13\insrsid16718750\charrsid16718750 
\loch\af13\hich\af13\dbch\f13 \'d6\'b8\'d5\'eb}{\cf6\hich\af13\insrsid16718750\charrsid16718750 \hich\af13\dbch\af13\loch\f13 ,}{\cf6\hich\af13\insrsid16718750\charrsid16718750 \loch\af13\hich\af13\dbch\f13 \'cb\'fc\'d6\'b8\'cf\'f2\'b5\'b1\'c7\'b0\'d5\'fd
\'d4\'da\'d4\'cb\'d0\'d0\'b5\'c4\'bd\'f8\'b3\'cc}{\cf6\hich\af13\insrsid16718750\charrsid16718750 \hich\af13\dbch\af13\loch\f13 .
\par }{\hich\af13\insrsid10314595\charrsid10314595 \tab }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 /*
\par \tab \hich\af13\dbch\af13\loch\f13  * offsets of these are hardcoded elsewhere - touch with care
\par \tab \hich\af13\dbch\af13\loch\f13  */
\par \tab \hich\af13\dbch\af13\loch\f13 volatile long state;\tab /*}{\cf6\hich\af13\insrsid10314595\charrsid13897779 \loch\af13\hich\af13\dbch\f13 \'bd\'f8\'b3\'cc\'d7\'b4\'cc\'ac}{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 
 -1 unrunnable, 0 runnable, >0 stopped */
\par \tab \hich\af13\dbch\af13\loch\f13 unsigned \hich\af13\dbch\af13\loch\f13 long flags;\tab /* }{\cf6\hich\af13\insrsid10314595\charrsid13897779 \loch\af13\hich\af13\dbch\f13 \'bd\'f8\'b3\'cc\'b1\'ea\'d6\'be}{\hich\af13\insrsid10314595\charrsid10314595 
\hich\af13\dbch\af13\loch\f13 per process flags, defined below */
\par \tab \hich\af13\dbch\af13\loch\f13 int sigpending;
\par \tab \hich\af13\dbch\af13\loch\f13 mm_segment_t addr_limit;\tab /* thread address space:
\par \tab \tab \tab \tab \tab \hich\af13\dbch\af13\loch\f13  \tab 0-0xBFFFFFFF for user-thead
\par \tab \tab \tab \tab \tab \tab \hich\af13\dbch\af13\loch\f13 0-0xFFFFFFFF for kernel-thread
\par \tab \tab \tab \tab \tab \hich\af13\dbch\af13\loch\f13  */
\par \tab \hich\af13\dbch\af13\loch\f13 struct exec_domain *exec_domain;
\par \tab \hich\af13\dbch\af13\loch\f13 volatile long nee\hich\af13\dbch\af13\loch\f13 d_resched;
\par \tab \hich\af13\dbch\af13\loch\f13 unsigned long ptrace;
\par 
\par \tab \hich\af13\dbch\af13\loch\f13 int lock_depth;\tab \tab /* Lock depth */
\par 
\par \hich\af13\dbch\af13\loch\f13 /*
\par \hich\af13\dbch\af13\loch\f13  * offset 32 begins here on 32-bit platforms. We keep
\par \hich\af13\dbch\af13\loch\f13  * all fields in a single cacheline that are needed for
\par \hich\af13\dbch\af13\loch\f13  * the goodness() loop in schedule().
\par \hich\af13\dbch\af13\loch\f13  */
\par \tab \hich\af13\dbch\af13\loch\f13 long counter;}{\cf6\hich\af13\insrsid15432943\charrsid15432943 \hich\af13\dbch\af13\loch\f13 /*}{\cf6\hich\af13\insrsid15432943\charrsid15432943 \loch\af13\hich\af13\dbch\f13 \'bd\'f8\'b3\'cc\'b5\'f7\'b6\'c8\'d0\'c5
\'cf\'a2}{\cf6\hich\af13\insrsid9899319 \hich\af13\dbch\af13\loch\f13 ,}{\cf6\hich\af13\insrsid9899319 \loch\af13\hich\af13\dbch\f13 \'bd\'f8\'b3\'cc\'ca\'b9\'d3\'c3}{\cf6\hich\af13\insrsid9899319 \hich\af13\dbch\af13\loch\f13 CPU}{
\cf6\hich\af13\insrsid9899319 \loch\af13\hich\af13\dbch\f13 \'d4\'cb\'d0\'d0\'ca\'b1\'bc\'e4\'b5\'c4\'bc\'c6\'ca\'fd\'d6\'b5\'a3\'ac}{\cf6\hich\af13\insrsid9899319 \hich\af13\dbch\af13\loch\f13 0}{\cf6\hich\af13\insrsid9899319 
\loch\af13\hich\af13\dbch\f13 \'b1\'ed\'ca\'be\'bd\'f8\'b3\'cc\'b5\'c4\'ca\'b1\'bc\'e4\'c6\'ac\'d2\'d1\'d3\'c3\'cd\'ea\'a3\'ac\'bd\'f8\'b3\'cc\'b5\'f7\'b6\'c8\'bd\'ab\'cd\'a3\'d6\'b9\'b8\'c3\'bd\'f8\'b3\'cc\'b5\'c4\'d4\'cb\'d0\'d0\'a3\'ac\'b0\'d1}{
\cf6\hich\af13\insrsid9899319 \hich\af13\dbch\af13\loch\f13 CPU}{\cf6\hich\af13\insrsid9899319 \loch\af13\hich\af13\dbch\f13 \'b7\'d6\'c5\'e4\'b8\'f8\'cf\'c2\'d2\'bb\'b8\'f6\'bd\'f8\'b3\'cc}{\cf6\hich\af13\insrsid9899319 \hich\af13\dbch\af13\loch\f13 */}{
\cf6\hich\af13\insrsid10314595\charrsid9899319 
\par }{\hich\af13\insrsid10314595\charrsid10314595 \tab }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 long nice;
\par \tab \hich\af13\dbch\af13\loch\f13 unsigned long policy;}{\cf6\hich\af13\insrsid15432943\charrsid15432943 \hich\af13\dbch\af13\loch\f13  /*}{\cf6\hich\af13\insrsid15432943\charrsid15432943 \loch\af13\hich\af13\dbch\f13 \'bd\'f8\'b3\'cc\'b5\'f7\'b6\'c8
\'d0\'c5\'cf\'a2}{\cf6\hich\af13\insrsid16063122 \loch\af13\hich\af13\dbch\f13 \'a3\'ac\'bd\'f8\'b3\'cc\'b5\'f7\'b6\'c8\'b2\'df\'c2\'d4\'a3\'a8\'cb\'e3\'b7\'a8\'a3\'a9}{\cf6\hich\af13\insrsid15432943\charrsid15432943 \hich\af13\dbch\af13\loch\f13 */}{
\hich\af13\insrsid10314595\charrsid10314595 
\par \tab }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 struct mm_struct *mm;}{\cf6\hich\af13\insrsid7305034\charrsid7305034 \hich\af13\dbch\af13\loch\f13 /*}{\cf6\hich\af13\insrsid7305034\charrsid7305034 
\loch\af13\hich\af13\dbch\f13 \'b6\'d4\'d0\'e9\'b4\'e6\'bf\'d5\'bc\'e4\'b9\'dc\'c0\'ed\'d3\'c3\'b5\'c4\'b3\'c9\'d4\'b1\'cf\'ee}{\cf6\hich\af13\insrsid7305034\charrsid7305034 \hich\af13\dbch\af13\loch\f13 */}{\hich\af13\insrsid10314595\charrsid10314595 

\par \tab }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 int has_cpu, processor;
\par \tab \hich\af13\dbch\af13\loch\f13 unsigned long cpus_allowed;
\par \tab \hich\af13\dbch\af13\loch\f13 /*
\par \tab \hich\af13\dbch\af13\loch\f13  * (only the 'next' pointer fits into the cachelin\hich\af13\dbch\af13\loch\f13 e, but
\par \tab \hich\af13\dbch\af13\loch\f13  * that's just fine.)
\par \tab \hich\af13\dbch\af13\loch\f13  */
\par \tab \hich\af13\dbch\af13\loch\f13 struct list_head run_list;
\par \tab \hich\af13\dbch\af13\loch\f13 unsigned long sleep_time;
\par 
\par \tab \hich\af13\dbch\af13\loch\f13 struct task_struct *next_task, *prev_task;}{\hich\af13\insrsid15432943 \hich\af13\dbch\af13\loch\f13 /*}{\cf6\hich\af13\insrsid15432943\charrsid15432943 \loch\af13\hich\af13\dbch\f13 \'bd\'f8\'b3\'cc\'d6\'ae\'bc\'e4
\'b5\'c4\'c1\'b4\'bd\'d3\'b9\'d8\'cf\'b5}{\cf6\hich\af13\insrsid2892992 \hich\af13\dbch\af13\loch\f13 ,}{\hich\af13\insrsid2892992\charrsid2892992 \hich\af13\dbch\af13\loch\f13  }{\cf6\hich\af13\insrsid2892992\charrsid2892992 
\hich\af13\dbch\af13\loch\f13 next_task }{\cf6\hich\af13\insrsid2892992\charrsid2892992 \loch\af13\hich\af13\dbch\f13 \'d6\'b8\'cf\'f2\'cf\'c2\'d2\'bb\'b8\'f6\'c8\'ce\'ce\'f1\'bd\'e1\'b9\'b9\'cc\'e5\'b5\'c4\'d6\'b8\'d5\'eb}{
\cf6\hich\af13\insrsid2892992\charrsid2892992 \hich\af13\dbch\af13\loch\f13 , prev_task }{\cf6\hich\af13\insrsid2892992\charrsid2892992 \loch\af13\hich\af13\dbch\f13 \'d6\'b8\'cf\'f2\'c7\'b0\'d2\'bb\'b8\'f6\'c8\'ce\'ce\'f1\'bd\'e1\'b9\'b9\'cc\'e5\'b5\'c4
\'d6\'b8\'d5\'eb}{\cf6\hich\af13\insrsid15432943\charrsid2892992 \hich\af13\dbch\af13\loch\f13 *}{\hich\af13\insrsid15432943 \hich\af13\dbch\af13\loch\f13 /}{\hich\af13\insrsid10314595\charrsid10314595 
\par \tab }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 struct mm_struct *active_mm;
\par 
\par \hich\af13\dbch\af13\loch\f13 /* task state */
\par \tab \hich\af13\dbch\af13\loch\f13 struct linux_binfmt *binfmt;}{\hich\af13\insrsid10314595\charrsid10314595 
\par \tab }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 int exit_code, exit_signal;}{\cf6\hich\af13\insrsid1712697\charrsid1712697 \hich\af13\dbch\af13\loch\f13  /*}{\cf6\hich\af13\insrsid1712697\charrsid1712697 
\loch\af13\hich\af13\dbch\f13 \'d3\'eb\'bd\'f8\'b3\'cc\'bc\'e4\'cd\'a8\'d0\'c5\'d3\'d0\'b9\'d8\'b5\'c4\'d0\'c5\'cf\'a2}{\cf6\hich\af13\insrsid1712697\charrsid1712697 \hich\af13\dbch\af13\loch\f13 */}{\hich\af13\insrsid10314595\charrsid10314595 
\par \tab }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 int pdeath_signal;  /*  The signal sent when the parent dies  */
\par \tab \hich\af13\dbch\af13\loch\f13 /* ??? */
\par \tab \hich\af13\dbch\af13\loch\f13 unsigned long personality;
\par \tab \hich\af13\dbch\af13\loch\f13 int dumpable:1;
\par \tab \hich\af13\dbch\af13\loch\f13 int did_exec:1;
\par \tab \hich\af13\dbch\af13\loch\f13 pid_t pid;}{\cf6\hich\af13\insrsid16062596\charrsid16062596 \loch\af13\hich\af13\dbch\f13 \'bd\'f8\'b3\'cc\'b1\'ea\'ca\'b6\'ba\'c5}{\hich\af13\insrsid10314595\charrsid10314595 
\par \tab }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 pid_t pgrp;
\par \tab \hich\af13\dbch\af13\loch\f13 pid_t tty_old_pgrp;
\par \tab \hich\af13\dbch\af13\loch\f13 pid_t session;
\par \tab \hich\af13\dbch\af13\loch\f13 pid_t tgid;
\par \tab \hich\af13\dbch\af13\loch\f13 /* boolean value for session group leader */
\par \tab \hich\af13\dbch\af13\loch\f13 int leader;
\par \tab \hich\af13\dbch\af13\loch\f13 /* 
\par \tab \hich\af13\dbch\af13\loch\f13  * pointers to (original) parent process, youngest child, younger sibling,
\par \tab \hich\af13\dbch\af13\loch\f13  * older sibling, respectively.  (p->father can be replaced with 
\par \tab \hich\af13\dbch\af13\loch\f13  * p->p_pptr->pid)
\par \tab \hich\af13\dbch\af13\loch\f13  */
\par \tab \hich\af13\dbch\af13\loch\f13 struct task_struct *p_opptr, *p_pptr, *p_cptr, *p_ysptr, *p_osptr;}{\hich\af13\insrsid4858544 \hich\af13\dbch\af13\loch\f13 /*}{\cf6\hich\af13\insrsid4858544\charrsid4858544 \loch\af13\hich\af13\dbch\f13 \'bd\'f8\'b3\'cc
\'d6\'ae\'bc\'e4\'b5\'c4\'d7\'e5\'c7\'d7\'b9\'d8}{\cf6\hich\af13\insrsid4858544\charrsid5923536 \loch\af13\hich\af13\dbch\f13 \'cf\'b5}{\cf6\hich\af13\insrsid5923536\charrsid5923536 \hich\af13\dbch\af13\loch\f13 , *p_oppt}{
\cf6\hich\af13\insrsid5923536\charrsid1601431 \hich\af13\dbch\af13\loch\f13 r }{\cf6\hich\af13\insrsid5923536\charrsid1601431 \loch\af13\hich\af13\dbch\f13 \'ca\'c7\'d6\'b8\'cf\'f2\'d7\'e6\'cf\'c8\'bd\'f8\'b3\'cc\'c8\'ce\'ce\'f1\'bd\'e1\'b9\'b9\'cc\'e5
\'b5\'c4\'d6\'b8\'d5\'eb}{\cf6\hich\af13\insrsid5923536\charrsid1601431 \hich\af13\dbch\af13\loch\f13 ,}{\cf6\hich\af13\insrsid1601431\charrsid1601431 \hich\af13\dbch\af13\loch\f13  *p_pptr }{\cf6\hich\af13\insrsid1601431\charrsid1601431 
\loch\af13\hich\af13\dbch\f13 \'ca\'c7\'d6\'b8\'cf\'f2\'b8\'b8\'bd\'f8\'b3\'cc\'c8\'ce\'ce\'f1\'bd\'e1\'b9\'b9\'cc\'e5\'b5\'c4\'d6\'b8\'d5\'eb}{\cf6\hich\af13\insrsid1601431\charrsid1601431 \hich\af13\dbch\af13\loch\f13 , *p_cptr }{
\cf6\hich\af13\insrsid1601431\charrsid1601431 \loch\af13\hich\af13\dbch\f13 \'ca\'c7\'d7\'d3\'bd\'f8\'b3\'cc\'c8\'ce\'ce\'f1\'bd\'e1\'b9\'b9\'cc\'e5\'b5\'c4\'d6\'b8\'d5\'eb}{\cf6\hich\af13\insrsid8335250 \hich\af13\dbch\af13\loch\f13 ,}{
\cf6\hich\af13\insrsid8335250 \loch\af13\hich\af13\dbch\f13 \'d6\'b8\'cf\'f2\'bd\'f8\'b3\'cc\'cb\'f9\'d3\'d0\'d7\'d3\'bd\'f8\'b3\'cc\'d6\'d0\'d7\'ee\'c4\'ea\'d3\'d7\'b5\'c4\'d2\'bb\'b8\'f6}{\cf6\hich\af13\insrsid8335250 \hich\af13\dbch\af13\loch\f13 ,}{
\cf6\hich\af13\insrsid8335250 \loch\af13\hich\af13\dbch\f13 \'bc\'b4\'d7\'ee\'bd\'fc\'b4\'b4\'bd\'a8\'b5\'c4\'c4\'c7\'b8\'f6\'d7\'d3\'bd\'f8\'b3\'cc}{\cf6\hich\af13\insrsid1601431\charrsid1601431 \hich\af13\dbch\af13\loch\f13 , *p_ysptr }{
\cf6\hich\af13\insrsid1601431\charrsid1601431 \loch\af13\hich\af13\dbch\f13 \'d6\'b8\'cf\'f2\'b5\'dc\'bd\'f8\'b3\'cc\'c8\'ce\'ce\'f1\'bd\'e1\'b9\'b9\'cc\'e5\'b5\'c4\'d6\'b8\'d5\'eb}{\cf6\hich\af13\insrsid1601431\charrsid1601431 
\hich\af13\dbch\af13\loch\f13 , *p_osptr }{\cf6\hich\af13\insrsid1601431\charrsid1601431 \loch\af13\hich\af13\dbch\f13 \'d6\'b8\'cf\'f2\'d0\'d6\'bd\'f8\'b3\'cc\'c8\'ce\'ce\'f1\'bd\'e1\'b9\'b9\'cc\'e5\'b5\'c4\'d6\'b8\'d5\'eb}{
\cf6\hich\af13\insrsid4858544\charrsid1601431 \hich\af13\dbch\af13\loch\f13 *}{\hich\af13\insrsid4858544 \hich\af13\dbch\af13\loch\f13 /}{\hich\af13\insrsid10314595\charrsid10314595 
\par \tab }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 struct list_head thread_group;
\par 
\par \tab \hich\af13\dbch\af13\loch\f13 /* PID hash table linkage. */
\par \tab \hich\af13\dbch\af13\loch\f13 struct task_struct *pidhash_next;}{\cf6\hich\af13\insrsid11300733\charrsid11300733 \hich\af13\dbch\af13\loch\f13  }{\cf6\hich\af13\insrsid11300733 \loch\af13\hich\af13\dbch\f13 \'ce\'aa\'d6\'b8\'cf\'f2\'ba\'f3\'d2\'bb
\'b8\'f6\'c8\'ce\'ce\'f1\'bd\'e1\'b9\'b9\'cc\'e5\'b5\'c4\'d6\'b8\'d5\'eb}{\hich\af13\insrsid10314595\charrsid10314595 
\par \tab }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 struct task_struct **pidhash_pprev;}{\cf6\hich\af13\insrsid11300733\charrsid11300733 \hich\af13\dbch\af13\loch\f13  }{\cf6\hich\af13\insrsid11300733 
\loch\af13\hich\af13\dbch\f13 \'ce\'aa\'d6\'b8\'cf\'f2\'c7\'b0\'d2\'bb\'b8\'f6\'c8\'ce\'ce\'f1\'bd\'e1\'b9\'b9\'cc\'e5\'b5\'c4\'d6\'b8\'d5\'eb}{\hich\af13\insrsid10314595\charrsid10314595 
\par 
\par \tab }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 wait_queue_head_t wait_chldexit;\tab /* for wait4() */
\par \tab \hich\af13\dbch\af13\loch\f13 struct semaphore *vfork_sem;\tab \tab /* for \hich\af13\dbch\af13\loch\f13 vfork() */
\par \tab \hich\af13\dbch\af13\loch\f13 unsigned long rt_priority;}{\cf6\hich\af13\insrsid15432943\charrsid15432943 \hich\af13\dbch\af13\loch\f13  /*}{\cf6\hich\af13\insrsid15432943\charrsid15432943 \loch\af13\hich\af13\dbch\f13 \'bd\'f8\'b3\'cc\'b5\'f7
\'b6\'c8\'d0\'c5\'cf\'a2}{\cf6\hich\af13\insrsid2824020 \hich\af13\dbch\af13\loch\f13 ,}{\cf6\hich\af13\insrsid2824020 \loch\af13\hich\af13\dbch\f13 \'ca\'b5\'ca\'b1\'bd\'f8\'b3\'cc\'b5\'c4\'d3\'c5\'cf\'c8\'bc\'b6}{
\cf6\hich\af13\insrsid15432943\charrsid15432943 \hich\af13\dbch\af13\loch\f13 */}{\hich\af13\insrsid10314595\charrsid10314595 
\par \tab }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 unsigned long it_real_value, it_prof_value, it_virt_value;
\par \tab \hich\af13\dbch\af13\loch\f13 unsigned long it_real_incr, it_prof_incr, it_virt_incr;
\par \tab \hich\af13\dbch\af13\loch\f13 struct timer_list real_timer;}{\cf6\hich\af13\insrsid15432943\charrsid15432943 \hich\af13\dbch\af13\loch\f13 /*}{\cf6\hich\af13\insrsid15432943\charrsid15432943 \loch\af13\hich\af13\dbch\f13 \'b6\'a8\'ca\'b1\'c6\'f7}{
\cf6\hich\af13\insrsid15432943\charrsid15432943 \hich\af13\dbch\af13\loch\f13 */}{\hich\af13\insrsid10314595\charrsid10314595 
\par \tab }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 struct tms times;
\par \tab \hich\af13\dbch\af13\loch\f13 unsigned long start_ti\hich\af13\dbch\af13\loch\f13 me;}{\cf6\hich\af13\insrsid15432943\charrsid15432943 \hich\af13\dbch\af13\loch\f13 /*}{\cf6\hich\af13\insrsid15432943\charrsid15432943 \loch\af13\hich\af13\dbch\f13 
\'cf\'b5\'cd\'b3\'ca\'b1\'bc\'e4}{\cf6\hich\af13\insrsid15432943\charrsid15432943 \hich\af13\dbch\af13\loch\f13 */}{\hich\af13\insrsid10314595\charrsid10314595 
\par \tab }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 long per_cpu_utime[NR_CPUS], per_cpu_stime[NR_CPUS];}{\cf6\hich\af13\insrsid15432943\charrsid15432943 \hich\af13\dbch\af13\loch\f13  /*}{
\cf6\hich\af13\insrsid15432943\charrsid15432943 \loch\af13\hich\af13\dbch\f13 \'cf\'b5\'cd\'b3\'ca\'b1\'bc\'e4}{\cf6\hich\af13\insrsid15432943\charrsid15432943 \hich\af13\dbch\af13\loch\f13 */}{\hich\af13\insrsid10314595\charrsid10314595 
\par }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 /* mm fault and swap info: this can arguably be seen as either mm-specific or thread-specific */
\par \tab \hich\af13\dbch\af13\loch\f13 unsigned long min_flt, maj_flt, nswap, cmin_flt, cmaj_flt, cnswap;
\par \tab \hich\af13\dbch\af13\loch\f13 int swappable:1;
\par \hich\af13\dbch\af13\loch\f13 /* process credentials */
\par \tab \hich\af13\dbch\af13\loch\f13 uid_t uid,euid,suid,fsuid;
\par \tab \hich\af13\dbch\af13\loch\f13 gid_t gid,egid,sgid,fsgid;
\par \tab \hich\af13\dbch\af13\loch\f13 int ngroups;
\par \tab \hich\af13\dbch\af13\loch\f13 gid_t\tab groups[NGROUPS];
\par \tab \hich\af13\dbch\af13\loch\f13 kernel_cap_t   cap_effective, cap_inheritable, cap_permitted;
\par \tab \hich\af13\dbch\af13\loch\f13 int keep_capabilities:1;
\par \tab \hich\af13\dbch\af13\loch\f13 struct user_struct *user;
\par \hich\af13\dbch\af13\loch\f13 /* \hich\af13\dbch\af13\loch\f13 limits */
\par \tab \hich\af13\dbch\af13\loch\f13 struct rlimit rlim[RLIM_NLIMITS];
\par \tab \hich\af13\dbch\af13\loch\f13 unsigned short used_math;
\par \tab \hich\af13\dbch\af13\loch\f13 char comm[16];
\par \hich\af13\dbch\af13\loch\f13 /* file system info */
\par \tab \hich\af13\dbch\af13\loch\f13 int link_count;
\par \tab \hich\af13\dbch\af13\loch\f13 struct tty_struct *tty; /* NULL if no tty */
\par \tab \hich\af13\dbch\af13\loch\f13 unsigned int locks; /* How many file locks are being held */
\par \hich\af13\dbch\af13\loch\f13 /* ipc stuff */
\par \tab \hich\af13\dbch\af13\loch\f13 str\hich\af13\dbch\af13\loch\f13 uct sem_undo *semundo;}{\cf6\hich\af13\insrsid1712697\charrsid1712697 \hich\af13\dbch\af13\loch\f13  /*}{\cf6\hich\af13\insrsid1712697\charrsid1712697 \loch\af13\hich\af13\dbch\f13 
\'d3\'eb\'bd\'f8\'b3\'cc\'bc\'e4\'cd\'a8\'d0\'c5\'d3\'d0\'b9\'d8\'b5\'c4\'d0\'c5\'cf\'a2}{\cf6\hich\af13\insrsid1712697\charrsid1712697 \hich\af13\dbch\af13\loch\f13 */}{\hich\af13\insrsid10314595\charrsid10314595 
\par \tab }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 struct sem_queue *semsleeping;}{\cf6\hich\af13\insrsid1712697\charrsid1712697 \hich\af13\dbch\af13\loch\f13  /*}{\cf6\hich\af13\insrsid1712697\charrsid1712697 
\loch\af13\hich\af13\dbch\f13 \'d3\'eb\'bd\'f8\'b3\'cc\'bc\'e4\'cd\'a8\'d0\'c5\'d3\'d0\'b9\'d8\'b5\'c4\'d0\'c5\'cf\'a2}{\cf6\hich\af13\insrsid1712697\charrsid1712697 \hich\af13\dbch\af13\loch\f13 */}{\hich\af13\insrsid10314595\charrsid10314595 
\par }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 /* CPU-specific state of this task */
\par \tab \hich\af13\dbch\af13\loch\f13 struct thread_struct thread;
\par \hich\af13\dbch\af13\loch\f13 /* filesystem information */
\par \tab \hich\af13\dbch\af13\loch\f13 struct fs_struct *fs;}{\cf6\hich\af13\insrsid7305034\charrsid7305034 \hich\af13\dbch\af13\loch\f13 /*}{\cf6\hich\af13\insrsid7305034\charrsid7305034 \loch\af13\hich\af13\dbch\f13 \'ce\'c4\'bc\'fe\'cf\'b5\'cd\'b3\'d0\'c5
\'cf\'a2}{\cf6\hich\af13\insrsid7305034\charrsid7305034 \hich\af13\dbch\af13\loch\f13 */}{\hich\af13\insrsid10314595\charrsid10314595 
\par }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 /* open file information */
\par \tab \hich\af13\dbch\af13\loch\f13 struct fil\hich\af13\dbch\af13\loch\f13 es_struct *files;}{\cf6\hich\af13\insrsid7305034\charrsid7305034 \hich\af13\dbch\af13\loch\f13  /*}{\cf6\hich\af13\insrsid7305034\charrsid7305034 \loch\af13\hich\af13\dbch\f13 
\'ce\'c4\'bc\'fe\'cf\'b5\'cd\'b3\'d0\'c5\'cf\'a2}{\cf6\hich\af13\insrsid7305034\charrsid7305034 \hich\af13\dbch\af13\loch\f13 */}{\hich\af13\insrsid10314595\charrsid10314595 
\par }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 /* signal handlers */
\par \tab \hich\af13\dbch\af13\loch\f13 spinlock_t sigmask_lock;\tab /* Protects signal and blocked */
\par \tab \hich\af13\dbch\af13\loch\f13 struct signal_struct *sig;}{\cf6\hich\af13\insrsid1712697\charrsid1712697 \hich\af13\dbch\af13\loch\f13 /*}{\cf6\hich\af13\insrsid1712697\charrsid1712697 \loch\af13\hich\af13\dbch\f13 \'d3\'eb\'bd\'f8\'b3\'cc\'bc\'e4
\'cd\'a8\'d0\'c5\'d3\'d0\'b9\'d8\'b5\'c4\'d0\'c5\'cf\'a2}{\cf6\hich\af13\insrsid10487966 \hich\af13\dbch\af13\loch\f13 , }{\cf6\hich\af13\insrsid10487966 \loch\af13\hich\af13\dbch\f13 \'d3\'c3\'d3\'da\'b4\'a6\'c0\'ed\'bd\'d3\'ca\'d5\'b5\'c4\'d0\'c5
\'ba\'c5}{\cf6\hich\af13\insrsid1712697\charrsid1712697 \hich\af13\dbch\af13\loch\f13 */}{\hich\af13\insrsid10314595\charrsid10314595 
\par 
\par \tab }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 sigset_t blocked;}{\cf6\hich\af13\insrsid1712697\charrsid1712697 \hich\af13\dbch\af13\loch\f13  /*}{\cf6\hich\af13\insrsid1712697\charrsid1712697 
\loch\af13\hich\af13\dbch\f13 \'d3\'eb\'bd\'f8\'b3\'cc\'bc\'e4\'cd\'a8\'d0\'c5\'d3\'d0\'b9\'d8\'b5\'c4\'d0\'c5\'cf\'a2}{\cf6\hich\af13\insrsid10487966 \hich\af13\dbch\af13\loch\f13 , }{\cf6\hich\af13\insrsid10487966 \loch\af13\hich\af13\dbch\f13 \'d3\'c3
\'d3\'da\'b4\'a6\'c0\'ed\'bd\'d3\'ca\'d5\'b5\'c4\'d0\'c5\'ba\'c5}{\cf6\hich\af13\insrsid1712697\charrsid1712697 \hich\af13\dbch\af13\loch\f13 */}{\hich\af13\insrsid10314595\charrsid10314595 
\par \tab }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 struct sigpending pending;
\par 
\par \tab \hich\af13\dbch\af13\loch\f13 unsigned long sas_ss_sp;
\par \tab \hich\af13\dbch\af13\loch\f13 size_t sas_ss_size;
\par \tab \hich\af13\dbch\af13\loch\f13 int (*notifier)(void *priv);
\par \tab \hich\af13\dbch\af13\loch\f13 void *notifier_data;
\par \tab \hich\af13\dbch\af13\loch\f13 sigset_t *notifier_mask;
\par \tab 
\par \hich\af13\dbch\af13\loch\f13 /* Thread group tracking */
\par \hich\af13\dbch\af13\loch\f13    \tab u32 parent_exec_id;
\par \hich\af13\dbch\af13\loch\f13    \tab u32 self_exec_id;
\par \hich\af13\dbch\af13\loch\f13 /* Protection of (de-)allocation: mm, files, fs, tty */
\par \tab \hich\af13\dbch\af13\loch\f13 spinlock_t alloc_lock;
\par \}\hich\af13\dbch\af13\loch\f13 ;
\par 
\par \hich\af13\dbch\af13\loch\f13 /*
\par \hich\af13\dbch\af13\loch\f13  * Per process flags
\par \hich\af13\dbch\af13\loch\f13  */
\par \hich\af13\dbch\af13\loch\f13 #define PF_ALIGNWARN\tab 0x00000001\tab /* Print alignment warning msgs */
\par \tab \tab \tab \tab \tab \hich\af13\dbch\af13\loch\f13 /* Not implemented yet, only for 486*/
\par \hich\af13\dbch\af13\loch\f13 #define PF_STARTING\tab 0x00000002\tab /* being created */
\par \hich\af13\dbch\af13\loch\f13 #define PF_EXITING\tab 0x00000004\tab /* getti\hich\af13\dbch\af13\loch\f13 ng shut down */
\par \hich\af13\dbch\af13\loch\f13 #define PF_FORKNOEXEC\tab 0x00000040\tab /* forked but didn't exec */
\par \hich\af13\dbch\af13\loch\f13 #define PF_SUPERPRIV\tab 0x00000100\tab /* used super-user privileges */
\par \hich\af13\dbch\af13\loch\f13 #define PF_DUMPCORE\tab 0x00000200\tab /* dumped core */
\par \hich\af13\dbch\af13\loch\f13 #define PF_SIGNALED\tab 0x00000400\tab /* killed by a signal */
\par \hich\af13\dbch\af13\loch\f13 #define PF_MEMALLOC\tab 0x00000800\tab /* Allocating memory */
\par \hich\af13\dbch\af13\loch\f13 #define PF_VFORK\tab 0x00001000\tab /* Wake up parent in mm_release */
\par 
\par \hich\af13\dbch\af13\loch\f13 #define PF_USEDFPU\tab 0x00100000\tab /* task used FPU this quantum (SMP) */
\par 
\par \hich\af13\dbch\af13\loch\f13 /*
\par \hich\af13\dbch\af13\loch\f13  * Ptrace flags
\par \hich\af13\dbch\af13\loch\f13  */
\par 
\par \hich\af13\dbch\af13\loch\f13 #define PT_PTRACED\tab 0x00000001
\par \hich\af13\dbch\af13\loch\f13 #define PT_TR\hich\af13\dbch\af13\loch\f13 ACESYS\tab 0x00000002
\par \hich\af13\dbch\af13\loch\f13 #define PT_DTRACE\tab 0x00000004\tab /* delayed trace (used on m68k, i386) */
\par \hich\af13\dbch\af13\loch\f13 #define PT_TRACESYSGOOD\tab 0x00000008
\par 
\par \hich\af13\dbch\af13\loch\f13 /*
\par \hich\af13\dbch\af13\loch\f13  * Limit the stack by to some sane default: root can always
\par \hich\af13\dbch\af13\loch\f13  * increase this limit if needed..  8MB seems reasonable.
\par \hich\af13\dbch\af13\loch\f13  */
\par \hich\af13\dbch\af13\loch\f13 #define\hich\af13\dbch\af13\loch\f13  _STK_LIM\tab (8*1024*1024)
\par 
\par \hich\af13\dbch\af13\loch\f13 #define DEF_COUNTER\tab (10*HZ/100)\tab /* 100 ms time slice */
\par \hich\af13\dbch\af13\loch\f13 #define MAX_COUNTER\tab (20*HZ/100)
\par \hich\af13\dbch\af13\loch\f13 #define DEF_NICE\tab (0)
\par 
\par \hich\af13\dbch\af13\loch\f13 /*
\par \hich\af13\dbch\af13\loch\f13  *  INIT_TASK is used to set up the first task table, touch at
\par \hich\af13\dbch\af13\loch\f13  * your own risk!. Base=0, limit=0x1fffff (=2MB)
\par \hich\af13\dbch\af13\loch\f13  */
\par \hich\af13\dbch\af13\loch\f13 #d\hich\af13\dbch\af13\loch\f13 efine INIT_TASK(tsk)\tab \\
\par \{\tab \tab \tab \tab \tab \tab \tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13     state:\tab \tab 0,\tab \tab \tab \tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13     flags:\tab \tab 0,\tab \tab \tab \tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13     sigpending:\tab \tab 0,\tab \tab \tab \tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13     addr_limit:\tab \tab KERNEL_DS,\tab \tab \tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13     exec_domain:\tab &default_exec_domain,\tab \tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13     lock_depth:\tab \tab -1,\tab \tab \tab \tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13     counter:\tab \tab DEF_COUNTER,\tab \tab \tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13     nice:\tab \tab \hich\af13\dbch\af13\loch\f13 DEF_NICE,\tab \tab \tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13     policy:\tab \tab SCHED_OTHER,\tab \tab \tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13     mm:\tab \tab \tab NULL,\tab \tab \tab \tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13     active_mm:\tab \tab &init_mm,\tab \tab \tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13     cpus_allowed:\tab -1,\tab \tab \tab \tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13     run_list:\tab \tab LIST_HEAD_INIT(tsk.run_list),\tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13     next_task:\tab \tab &tsk,\tab \tab \tab \tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13     prev_task:\tab \tab &tsk,\tab \tab \tab \tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13     p_opptr:\tab \tab &ts\hich\af13\dbch\af13\loch\f13 k,\tab \tab \tab \tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13     p_pptr:\tab \tab &tsk,\tab \tab \tab \tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13     thread_group:\tab LIST_HEAD_INIT(tsk.thread_group),\tab \tab \\
\par \hich\af13\dbch\af13\loch\f13     wait_chldexit:\tab __WAIT_QUEUE_HEAD_INITIALIZER(tsk.wait_chldexit),\\
\par \hich\af13\dbch\af13\loch\f13     real_timer:\tab \tab \{\tab \tab \tab \tab \tab \tab \\}{\cf6\hich\af13\insrsid15432943\charrsid15432943 \loch\af13\hich\af13\dbch\f13 \'b6\'a8\'ca\'b1\'c6\'f7}{\hich\af13\insrsid10314595\charrsid10314595 
\par \tab }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 function:\tab \tab it_real_fn\tab \tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13     \},\tab \tab \tab \tab \tab \tab \tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13     cap_effective:\tab CA\hich\af13\dbch\af13\loch\f13 P_INIT_EFF_SET,\tab \tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13     cap_inheritable:\tab CAP_INIT_INH_SET,\tab \tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13     cap_permitted:\tab CAP_FULL_SET,\tab \tab \tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13     keep_capabilities:\tab 0,\tab \tab \tab \tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13     rlim:\tab \tab INIT_RLIMITS,\tab \tab \tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13     user:\tab \tab INIT_USER,\tab \tab \tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13     comm:\tab \tab "swapper",\tab \tab \tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13     thread:\tab \tab INIT_THREAD,\tab \tab \tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13     fs:\tab \tab \tab &init_fs,\tab \tab \tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13     files:\tab \tab &init_files,\tab \tab \tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13     sigmask_lock:\tab SPIN_LOCK_UNLOCKED,\tab \tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13     sig:\tab \tab &init_signals,\tab \tab \tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13     pending:\tab \tab \{ NULL, &tsk.pending.head, \{\{0\}\}\},\tab \tab \\
\par \hich\af13\dbch\af13\loch\f13     blocked:\tab \tab \{\{0\}\},\tab \tab \tab \tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13     alloc_lock:\tab \tab SPIN_LOCK_UNLOCKED\tab \tab \tab \tab \\
\par \}
\par 
\par 
\par \hich\af13\dbch\af13\loch\f13 #ifndef INIT_TASK_SIZE
\par \hich\af13\dbch\af13\loch\f13 # define INIT_TASK_SIZE\tab 2048*sizeof(long)
\par \hich\af13\dbch\af13\loch\f13 #endif
\par 
\par \hich\af13\dbch\af13\loch\f13 union task_union \{
\par \tab \hich\af13\dbch\af13\loch\f13 struct task_struct task;
\par \tab \hich\af13\dbch\af13\loch\f13 unsigned long stack[INIT_TASK_SIZE/sizeof(long)];
\par \}\hich\af13\dbch\af13\loch\f13 ;
\par 
\par \hich\af13\dbch\af13\loch\f13 extern union task_union init_task_union;
\par 
\par \hich\af13\dbch\af13\loch\f13 extern struct   mm_struct init_mm;
\par \hich\af13\dbch\af13\loch\f13 extern\hich\af13\dbch\af13\loch\f13  struct task_struct *init_tasks[NR_CPUS];
\par 
\par \hich\af13\dbch\af13\loch\f13 /* PID hashing. (shouldnt this be dynamic?) */
\par \hich\af13\dbch\af13\loch\f13 #define PIDHASH_SZ (4096 >> 2)}{\hich\af13\insrsid4466615 \hich\af13\dbch\af13\loch\f13  }{\cf6\hich\af13\insrsid4466615\charrsid4466615 \hich\af13\dbch\af13\loch\f13 PIDHASH_SZ}{\cf6\hich\af13\insrsid4466615\charrsid4466615 
\loch\af13\hich\af13\dbch\f13 \'ca\'c7\'cf\'b5\'cd\'b3\'d6\'d0\'d7\'ee\'b6\'e0\'c8\'dd\'c4\'c9\'b5\'c4\'bd\'f8\'b3\'cc\'ca\'fd}{\cf6\hich\af13\insrsid4466615\charrsid4466615 \hich\af13\dbch\af13\loch\f13 NR_TASKS}{
\cf6\hich\af13\insrsid4466615\charrsid4466615 \loch\af13\hich\af13\dbch\f13 \'b3\'fd\'d2\'d4}{\cf6\hich\af13\insrsid4466615\charrsid4466615 \hich\af13\dbch\af13\loch\f13 4}{\hich\af13\insrsid10314595\charrsid10314595 
\par }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 extern struct task_struct }{\cf6\hich\af13\insrsid10314595\charrsid8930903 \hich\af13\dbch\af13\loch\f13 *pidhash}{\hich\af13\insrsid10314595\charrsid10314595 
\hich\af13\dbch\af13\loch\f13 [PIDHASH_SZ];
\par }{\cf6\hich\af13\insrsid8930903\charrsid4466615 \loch\af13\hich\af13\dbch\f13 \'d6\'b8\'d5\'eb\'ca\'fd\'d7\'e9}{\cf6\hich\af13\insrsid8930903\charrsid4466615 \hich\af13\dbch\af13\loch\f13 pidhash}{\cf6\hich\af13\insrsid8930903\charrsid4466615 
\loch\af13\hich\af13\dbch\f13 \'ce\'aa\'bd\'f8\'b3\'cc\'b1\'ea\'ca\'b6\'b9\'fe\'cf\'a3\'b1\'ed}{\cf6\hich\af13\insrsid8930903\charrsid4466615 \hich\af13\dbch\af13\loch\f13 ,}{\cf6\hich\af13\insrsid8930903\charrsid4466615 \loch\af13\hich\af13\dbch\f13 
\'b9\'dc\'c0\'ed\'b9\'fe\'cf\'a3\'cb\'ab\'cf\'f2\'c1\'b4\'b1\'ed}{\cf6\hich\af13\insrsid8930903\charrsid4466615 \hich\af13\dbch\af13\loch\f13 ,}{\cf6\hich\af13\insrsid8930903\charrsid4466615 \loch\af13\hich\af13\dbch\f13 \'bc\'c7\'c2\'bc\'d7\'c5\'b8\'f7
\'c1\'b4\'b1\'ed\'ca\'d7\'bd\'da\'b5\'e3\'b5\'c4\'b5\'d8\'d6\'b7}{\cf6\hich\af13\insrsid8930903\charrsid4466615 \hich\af13\dbch\af13\loch\f13 ,}{\cf6\hich\af13\insrsid8930903\charrsid4466615 \loch\af13\hich\af13\dbch\f13 \'ca\'fd\'d7\'e9\'d4\'aa\'cb\'d8
\'b5\'c4\'cf\'c2\'b1\'ea\'d3\'eb\'c1\'b4\'b1\'ed\'b5\'c4\loch\af13\hich\af13\dbch\f13 \'b9\'fe\'cf\'a3\'d6\'b5\'cf\'e0\'cd\'ac}{\cf6\hich\af13\insrsid8930903\charrsid4466615 \hich\af13\dbch\af13\loch\f13 . }{\cf6\hich\af13\insrsid10314595\charrsid4466615 

\par }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 #define }{\cf6\hich\af13\insrsid10314595\charrsid1068131 \hich\af13\dbch\af13\loch\f13 pid_hashfn}{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 (x)
\tab }{\cf6\hich\af13\insrsid10314595\charrsid1068131 \hich\af13\dbch\af13\loch\f13 ((((x) >> 8) ^ (x)) & (PIDHASH_SZ - 1))}{\hich\af13\insrsid10314595\charrsid10314595 
\par }{\cf6\hich\af13\insrsid1068131\charrsid2305625 \hich\af13\dbch\af13\loch\f13 pid_hashfn}{\cf6\hich\af13\insrsid1068131\charrsid2305625 \loch\af13\hich\af13\dbch\f13 \'bd\'f8\'b3\'cc\'b1\'ea\'ca\'b6\'b9\'fe\'cf\'a3\'b1\'ed}{
\cf6\hich\af13\insrsid1068131\charrsid2305625 \hich\af13\dbch\af13\loch\f13 :}{\cf6\hich\af13\insrsid1068131\charrsid2305625 \loch\af13\hich\af13\dbch\f13 \'b0\'b4\'b9\'fe\'cf\'a3\'cb\'e3\'b7\'a8\'b4\'d3\'bd\'f8\'d0\'d0\'b5\'c4}{
\cf6\hich\af13\insrsid1068131\charrsid2305625 \hich\af13\dbch\af13\loch\f13 PID}{\cf6\hich\af13\insrsid1068131\charrsid2305625 \loch\af13\hich\af13\dbch\f13 \'bf\'ec\'cb\'d9\'b2\'e9\'d5\'d2\'b6\'d4\'d3\'a6\'c8\'ce\'ce\'f1\'bd\'e1\'b9\'b9\'cc\'e5}{
\cf6\hich\af13\insrsid2305625\charrsid2305625 \hich\af13\dbch\af13\loch\f13 ,x}{\cf6\hich\af13\insrsid2305625\charrsid2305625 \loch\af13\hich\af13\dbch\f13 \'ce\'aa\'bd\'f8\'b3\'cc\'b5\'c4\'b1\'ea\'ca\'b6\'ba\'c5}{
\cf6\hich\af13\insrsid2305625\charrsid2305625 \hich\af13\dbch\af13\loch\f13 pid}{\cf6\hich\af13\insrsid16477490 \hich\af13\dbch\af13\loch\f13 ,pid}{\cf6\hich\af13\insrsid16477490 \loch\af13\hich\af13\dbch\f13 \'ce\'aa}{\cf6\hich\af13\insrsid16477490 
\hich\af13\dbch\af13\loch\f13 228}{\cf6\hich\af13\insrsid16477490 \loch\af13\hich\af13\dbch\f13 \'ba\'cd}{\cf6\hich\af13\insrsid16477490 \hich\af13\dbch\af13\loch\f13 27535}{\cf6\hich\af13\insrsid16477490 \loch\af13\hich\af13\dbch\f13 \'ba\'cd\'b9\'fe
\'cf\'a3\'d6\'b5\'ce\'aa}{\cf6\hich\af13\insrsid16477490 \hich\af13\dbch\af13\loch\f13 100,pid}{\cf6\hich\af13\insrsid16477490 \loch\af13\hich\af13\dbch\f13 \'ce\'aa}{\cf6\hich\af13\insrsid16477490 \hich\af13\dbch\af13\loch\f13 27536}{
\cf6\hich\af13\insrsid16477490 \loch\af13\hich\af13\dbch\f13 \'b5\'c4\'b9\'fe\'cf\'a3\'d6\'b5\'ce\'aa}{\cf6\hich\af13\insrsid16477490 \hich\af13\dbch\af13\loch\f13 123}{\cf6\hich\af13\insrsid16477490\charrsid16477490 
\par }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 static inline void hash_pid(struct task_struct *p)}{\hich\af13\insrsid10314595\charrsid10314595 
\par \{}{\cf6\hich\af13\insrsid2838352 \loch\af13\hich\af13\dbch\f13 \'b5\'b1\'d2\'bb\'b8\'f6\'bd\'f8\'b3\'cc\'b4\'b4\'bd\'a8\'ba\'f3}{\cf6\hich\af13\insrsid2838352 \hich\af13\dbch\af13\loch\f13 ,}{\cf6\hich\af13\insrsid2838352 \loch\af13\hich\af13\dbch\f13 
\'b0\'d1\'c8\'ce\'ce\'f1\'bd\'e1\'b9\'b9\'cc\'e5\'b2\'e5\'c8\'eb\'b9\'fe\'cf\'a3\'b1\'ed\'b5\'c4\'cf\'e0\'d3\'a6\'c1\'b4\'b1\'ed\'d6\'d0}{\cf6\hich\af13\insrsid10314595\charrsid2838352 
\par }{\hich\af13\insrsid10314595\charrsid10314595 \tab }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 struct task_struct **htable = &pidhash[pid_hashfn(p->pid)];
\par 
\par \tab \hich\af13\dbch\af13\loch\f13 if((p->}{\cf6\hich\af13\insrsid10314595\charrsid16477490 \hich\af13\dbch\af13\loch\f13 pidhash_next}{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13  = *htable) != NULL)}{
\hich\af13\insrsid16477490 \hich\af13\dbch\af13\loch\f13   }{\cf6\hich\af13\insrsid16477490\charrsid16477490 \hich\af13\dbch\af13\loch\f13 pidhash_next}{\cf6\hich\af13\insrsid16477490 \loch\af13\hich\af13\dbch\f13 \'d6\'b8\'cf\'f2\'cf\'c2\'d2\'bb\'b8\'f6
\'c8\'ce\'ce\'f1\'bd\'e1\'b9\'b9\'cc\'e5\'b5\'c4\'d6\'b8\'d5\'eb}{\hich\af13\insrsid10314595\charrsid10314595 
\par \tab \tab }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 (*htable)->}{\cf6\hich\af13\insrsid10314595\charrsid16477490 \hich\af13\dbch\af13\loch\f13 pidhash_pprev}{\hich\af13\insrsid10314595\charrsid10314595 
\hich\af13\dbch\af13\loch\f13  = &p->pidhash_next;
\par \tab \hich\af13\dbch\af13\loch\f13 *htable = p;
\par \tab \hich\af13\dbch\af13\loch\f13 p->pidhash_pprev = htable;}{\cf6\hich\af13\insrsid16477490\charrsid16477490 \hich\af13\dbch\af13\loch\f13  pidhash_pprev}{\cf6\hich\af13\insrsid16477490 \loch\af13\hich\af13\dbch\f13 \'ce\'aa\'d6\'b8\'cf\'f2\'c7\'b0
\'d2\'bb\'b8\'f6\'c8\'ce\'ce\'f1\'bd\'e1\'b9\'b9\'cc\'e5\'b5\'c4\'d6\'b8\'d5\'eb}{\hich\af13\insrsid10314595\charrsid10314595 
\par \}
\par 
\par }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 static \hich\af13\dbch\af13\loch\f13 inline void unhash_pid(struct task_struct *p)
\par \{}{\cf6\hich\af13\insrsid2838352 \loch\af13\hich\af13\dbch\f13 \'b5\'b1\'bd\'f8\'b3\'cc\'b1\'bb\'b3\'b7\'cf\'fb\'ca\'b1}{\cf6\hich\af13\insrsid2838352 \hich\af13\dbch\af13\loch\f13 ,}{\cf6\hich\af13\insrsid2838352 \loch\af13\hich\af13\dbch\f13 \'b0\'d1
\'c8\'ce\'ce\'f1\'bd\'e1\'b9\'b9\'cc\'e5\'b4\'d3\'b9\'fe\'cf\'a3\'b1\'ed\'c1\'b4\'b1\'ed\'d6\'d0\'c9\'be\'b3\'fd}{\cf6\hich\af13\insrsid10314595\charrsid2838352 
\par }{\hich\af13\insrsid10314595\charrsid10314595 \tab }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 if(p->pidhash_next)
\par \tab \tab \hich\af13\dbch\af13\loch\f13 p->pidhash_next->pidhash_pprev = p->pidhash_pprev;
\par \tab \hich\af13\dbch\af13\loch\f13 *p->pidhash_pprev = p->pidhash_next;
\par \}
\par 
\par \hich\af13\dbch\af13\loch\f13 static inline struct task_struct *find_task_by_pid(int pid)
\par \{}{\cf6\hich\af13\insrsid4028773 \loch\af13\hich\af13\dbch\f13 \'b4\'d3\'bd\'f8\'b3\'cc\'b5\'c4}{\cf6\hich\af13\insrsid4028773 \hich\af13\dbch\af13\loch\f13 pid}{\cf6\hich\af13\insrsid4028773 \loch\af13\hich\af13\dbch\f13 \'b2\'e9\'d5\'d2
\loch\af13\hich\af13\dbch\f13 \'bd\'f8\'b3\'cc\'b5\'c4\'c8\'ce\'ce\'f1\'bd\'e1\'b9\'b9\'cc\'e5}{\cf6\hich\af13\insrsid4028773\charrsid4028773 
\par }{\hich\af13\insrsid10314595\charrsid10314595 \tab }{\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 struct task_struct *p, **htable = &}{\cf6\hich\af13\insrsid10314595\charrsid11300733 \hich\af13\dbch\af13\loch\f13 pidhash}{
\hich\af13\insrsid10314595\charrsid10314595 \hich\af13\dbch\af13\loch\f13 [pid_hashfn(pid)];
\par 
\par \tab \hich\af13\dbch\af13\loch\f13 for(p = *htable; p && p->pid != pid; p = p->pidhash_next)
\par \tab \tab \hich\af13\dbch\af13\loch\f13 ;
\par 
\par \tab \hich\af13\dbch\af13\loch\f13 return p;
\par \}
\par 
\par \hich\af13\dbch\af13\loch\f13 /* per-UID process charging. */
\par \hich\af13\dbch\af13\loch\f13 extern struct user_struct * alloc_uid(uid_t);
\par \hich\af13\dbch\af13\loch\f13 extern void free_uid(struct user_struct *);
\par 
\par \hich\af13\dbch\af13\loch\f13 #include <asm/current.h>
\par 
\par \hich\af13\dbch\af13\loch\f13 extern unsigned long volatile jiffies;
\par \hich\af13\dbch\af13\loch\f13 extern unsigned long itimer_ticks;
\par \hich\af13\dbch\af13\loch\f13 extern unsigned long itimer_next;
\par \hich\af13\dbch\af13\loch\f13 extern struct timeval xtime;
\par \hich\af13\dbch\af13\loch\f13 extern void do_timer(struct pt_regs *);}{\cf6\hich\af13\insrsid9600920\charrsid9600920 \hich\af13\dbch\af13\loch\f13 //}{\cf6\hich\af13\insrsid9600920\charrsid9600920 \loch\af13\hich\af13\dbch\f13 \'b6\'a8
\loch\af13\hich\af13\dbch\f13 \'ca\'b1\loch\af13\hich\af13\dbch\f13 \'c6\'f7\loch\af13\hich\af13\dbch\f13 \'b5\'c4\loch\af13\hich\af13\dbch\f13 \'c9\'cf\loch\af13\hich\af13\dbch\f13 \'b0\'eb\loch\af13\hich\af13\dbch\f13 \'b2\'bf\'b7\'d6}{
\cf6\hich\af13\insrsid10314595\charrsid9600920 
\par }{\hich\af13\insrsid10314595\charrsid10314595 
\par \hich\af13\dbch\af13\loch\f13 extern \hich\af13\dbch\af13\loch\f13 unsigned int * prof_buffer;
\par \hich\af13\dbch\af13\loch\f13 extern unsigned long prof_len;
\par \hich\af13\dbch\af13\loch\f13 extern unsigned long prof_shift;
\par 
\par \hich\af13\dbch\af13\loch\f13 #define CURRENT_TIME (xtime.tv_sec)
\par 
\par \hich\af13\dbch\af13\loch\f13 extern void FASTCALL(__wake_up(wait_queue_head_t *q, unsigned int mode, unsigned int wq_mode));
\par \hich\af13\dbch\af13\loch\f13 extern void FASTCALL(__wake_up\hich\af13\dbch\af13\loch\f13 _sync(wait_queue_head_t *q, unsigned int mode, unsigned int wq_mode));
\par \hich\af13\dbch\af13\loch\f13 extern void FASTCALL(sleep_on(wait_queue_head_t *q));
\par \hich\af13\dbch\af13\loch\f13 extern long FASTCALL(sleep_on_timeout(wait_queue_head_t *q,
\par \tab \tab \tab \tab \hich\af13\dbch\af13\loch\f13       signed long timeout));
\par \hich\af13\dbch\af13\loch\f13 extern void FASTCALL(interruptible_sle\hich\af13\dbch\af13\loch\f13 ep_on(wait_queue_head_t *q));
\par \hich\af13\dbch\af13\loch\f13 extern long FASTCALL(interruptible_sleep_on_timeout(wait_queue_head_t *q,
\par \tab \tab \tab \tab \tab \tab \hich\af13\dbch\af13\loch\f13     signed long timeout));
\par \hich\af13\dbch\af13\loch\f13 extern void FASTCALL(wake_up_process(struct task_struct * tsk));
\par 
\par \hich\af13\dbch\af13\loch\f13 #define wake_up(x)\tab \tab \tab __wake_up((x),TASK_UNINTERRUPTIB\hich\af13\dbch\af13\loch\f13 LE | TASK_INTERRUPTIBLE,WQ_FLAG_EXCLUSIVE)
\par \hich\af13\dbch\af13\loch\f13 #define wake_up_all(x)\tab \tab \tab __wake_up((x),TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE,0)
\par \hich\af13\dbch\af13\loch\f13 #define wake_up_sync(x)\tab \tab \tab __wake_up_sync((x),TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE,WQ_FLAG_EXCLUSIVE)
\par \hich\af13\dbch\af13\loch\f13 #define wake_up_interru\hich\af13\dbch\af13\loch\f13 ptible(x)\tab __wake_up((x),TASK_INTERRUPTIBLE,WQ_FLAG_EXCLUSIVE)
\par \hich\af13\dbch\af13\loch\f13 #define wake_up_interruptible_all(x)\tab __wake_up((x),TASK_INTERRUPTIBLE,0)
\par \hich\af13\dbch\af13\loch\f13 #define wake_up_interruptible_sync(x)\tab __wake_up_sync((x),TASK_INTERRUPTIBLE,WQ_FLAG_EXCLUSIVE)
\par 
\par \hich\af13\dbch\af13\loch\f13 extern int in_group_p(gid\hich\af13\dbch\af13\loch\f13 _t);
\par \hich\af13\dbch\af13\loch\f13 extern int in_egroup_p(gid_t);
\par 
\par \hich\af13\dbch\af13\loch\f13 extern void proc_caches_init(void);
\par \hich\af13\dbch\af13\loch\f13 extern void flush_signals(struct task_struct *);
\par \hich\af13\dbch\af13\loch\f13 extern void flush_signal_handlers(struct task_struct *);
\par \hich\af13\dbch\af13\loch\f13 extern int dequeue_signal(sigset_t *, siginfo_t *);
\par \hich\af13\dbch\af13\loch\f13 extern void block_all_sig\hich\af13\dbch\af13\loch\f13 nals(int (*notifier)(void *priv), void *priv,
\par \tab \tab \tab \hich\af13\dbch\af13\loch\f13       sigset_t *mask);
\par \hich\af13\dbch\af13\loch\f13 extern void unblock_all_signals(void);
\par \hich\af13\dbch\af13\loch\f13 extern int send_sig_info(int, struct siginfo *, struct task_struct *);
\par \hich\af13\dbch\af13\loch\f13 extern int force_sig_info(int, struct siginfo *, struct task_struct *);
\par \hich\af13\dbch\af13\loch\f13 ex\hich\af13\dbch\af13\loch\f13 tern int kill_pg_info(int, struct siginfo *, pid_t);
\par \hich\af13\dbch\af13\loch\f13 extern int kill_sl_info(int, struct siginfo *, pid_t);
\par \hich\af13\dbch\af13\loch\f13 extern int kill_proc_info(int, struct siginfo *, pid_t);
\par \hich\af13\dbch\af13\loch\f13 extern void notify_parent(struct task_struct *, int);
\par \hich\af13\dbch\af13\loch\f13 extern void do_notify_parent(struct t\hich\af13\dbch\af13\loch\f13 ask_struct *, int);
\par \hich\af13\dbch\af13\loch\f13 extern void force_sig(int, struct task_struct *);
\par \hich\af13\dbch\af13\loch\f13 extern int send_sig(int, struct task_struct *, int);
\par \hich\af13\dbch\af13\loch\f13 extern int kill_pg(pid_t, int, int);
\par \hich\af13\dbch\af13\loch\f13 extern int kill_sl(pid_t, int, int);
\par \hich\af13\dbch\af13\loch\f13 extern int kill_proc(pid_t, int, int);
\par \hich\af13\dbch\af13\loch\f13 extern int do_sigaction(int, const struct k_sigaction *, struct k_sigaction *);
\par \hich\af13\dbch\af13\loch\f13 extern int do_sigaltstack(const stack_t *, stack_t *, unsigned long);
\par 
\par \hich\af13\dbch\af13\loch\f13 static inline int signal_pending(struct task_struct *p)
\par \{
\par \tab \hich\af13\dbch\af13\loch\f13 return (p->sigpending != 0);
\par \}
\par 
\par \hich\af13\dbch\af13\loch\f13 /*
\par \hich\af13\dbch\af13\loch\f13  * Re-calcu\hich\af13\dbch\af13\loch\f13 late pending state from the set of locally pending
\par \hich\af13\dbch\af13\loch\f13  * signals, globally pending signals, and blocked signals.
\par \hich\af13\dbch\af13\loch\f13  */
\par \hich\af13\dbch\af13\loch\f13 static inline int has_pending_signals(sigset_t *signal, sigset_t *blocked)
\par \{
\par \tab \hich\af13\dbch\af13\loch\f13 unsigned long ready;
\par \tab \hich\af13\dbch\af13\loch\f13 long i;
\par 
\par \tab \hich\af13\dbch\af13\loch\f13 switch (_NSIG_WORDS) \{
\par \tab \hich\af13\dbch\af13\loch\f13 default:
\par \tab \tab \hich\af13\dbch\af13\loch\f13 for (i = _NSIG_WORDS, ready = 0; --i >= 0 ;)
\par \tab \tab \tab \hich\af13\dbch\af13\loch\f13 ready |= signal->sig[i] &~ blocked->sig[i];
\par \tab \tab \hich\af13\dbch\af13\loch\f13 break;
\par 
\par \tab \hich\af13\dbch\af13\loch\f13 case 4: ready  = signal->sig[3] &~ blocked->sig[3];
\par \tab \tab \hich\af13\dbch\af13\loch\f13 ready |= signal->sig[2] &~ blocked->sig[2];
\par \tab \tab \hich\af13\dbch\af13\loch\f13 ready |= signal->sig[1] &~ blocked->sig[1];
\par \tab \tab \hich\af13\dbch\af13\loch\f13 read\hich\af13\dbch\af13\loch\f13 y |= signal->sig[0] &~ blocked->sig[0];
\par \tab \tab \hich\af13\dbch\af13\loch\f13 break;
\par 
\par \tab \hich\af13\dbch\af13\loch\f13 case 2: ready  = signal->sig[1] &~ blocked->sig[1];
\par \tab \tab \hich\af13\dbch\af13\loch\f13 ready |= signal->sig[0] &~ blocked->sig[0];
\par \tab \tab \hich\af13\dbch\af13\loch\f13 break;
\par 
\par \tab \hich\af13\dbch\af13\loch\f13 case 1: ready  = signal->sig[0] &~ blocked->sig[0];
\par \tab \}
\par \tab \hich\af13\dbch\af13\loch\f13 return ready !=\tab 0;
\par \}
\par 
\par \hich\af13\dbch\af13\loch\f13 /* Reevalu\hich\af13\dbch\af13\loch\f13 ate whether the task has signals pending delivery.
\par \hich\af13\dbch\af13\loch\f13    This is required every time the blocked sigset_t changes.
\par \hich\af13\dbch\af13\loch\f13    All callers should have t->sigmask_lock.  */
\par 
\par \hich\af13\dbch\af13\loch\f13 static inline void recalc_sigpending(struct task_struct *t)
\par \{
\par \tab \hich\af13\dbch\af13\loch\f13 t->sigpending = has_pending_sign\hich\af13\dbch\af13\loch\f13 als(&t->pending.signal, &t->blocked);
\par \}
\par 
\par \hich\af13\dbch\af13\loch\f13 /* True if we are on the alternate signal stack.  */
\par 
\par \hich\af13\dbch\af13\loch\f13 static inline int on_sig_stack(unsigned long sp)
\par \{
\par \tab \hich\af13\dbch\af13\loch\f13 return (sp - current->sas_ss_sp < current->sas_ss_size);
\par \}
\par 
\par \hich\af13\dbch\af13\loch\f13 static inline int sas_ss_flags(unsigned long sp)
\par \{
\par \tab \hich\af13\dbch\af13\loch\f13 return (current->sas_ss_size == 0 ? SS_DISABLE
\par \tab \tab \hich\af13\dbch\af13\loch\f13 : on_sig_stack(sp) ? SS_ONSTACK : 0);
\par \}
\par 
\par \hich\af13\dbch\af13\loch\f13 extern int request_irq(unsigned int,
\par \tab \tab \hich\af13\dbch\af13\loch\f13        void (*handler)(int, void *, struct pt_regs *),
\par \tab \tab \hich\af13\dbch\af13\loch\f13        unsigned long, const char *, void *);
\par \hich\af13\dbch\af13\loch\f13 extern void free_irq(unsigned int, void *);
\par 
\par \hich\af13\dbch\af13\loch\f13 /*
\par \hich\af13\dbch\af13\loch\f13  * This has now become a routine instead of a macro, it sets a flag if
\par \hich\af13\dbch\af13\loch\f13  * it returns true (to do BSD-style accounting where the process is flagged
\par \hich\af13\dbch\af13\loch\f13  * if it uses root privs). The implication of this is that yo\hich\af13\dbch\af13\loch\f13 u should do
\par \hich\af13\dbch\af13\loch\f13  * normal permissions checks first, and check suser() last.
\par \hich\af13\dbch\af13\loch\f13  *
\par \hich\af13\dbch\af13\loch\f13  * [Dec 1997 -- Chris Evans]
\par \hich\af13\dbch\af13\loch\f13  * For correctness, the above considerations need to be extended to
\par \hich\af13\dbch\af13\loch\f13  * fsuser(). This is done, along with moving fsuser() checks to be
\par \hich\af13\dbch\af13\loch\f13  * last.
\par \hich\af13\dbch\af13\loch\f13  *
\par \hich\af13\dbch\af13\loch\f13  * Th\hich\af13\dbch\af13\loch\f13 ese will be removed, but in the mean time, when the SECURE_NOROOT 
\par \hich\af13\dbch\af13\loch\f13  * flag is set, uids don't grant privilege.
\par \hich\af13\dbch\af13\loch\f13  */
\par \hich\af13\dbch\af13\loch\f13 static inline int suser(void)
\par \{
\par \tab \hich\af13\dbch\af13\loch\f13 if (!issecure(SECURE_NOROOT) && current->euid == 0) \{ 
\par \tab \tab \hich\af13\dbch\af13\loch\f13 current->flags |= PF_SUPERPRIV;
\par \tab \tab \hich\af13\dbch\af13\loch\f13 return 1;
\par \tab \}
\par \tab \hich\af13\dbch\af13\loch\f13 ret\hich\af13\dbch\af13\loch\f13 urn 0;
\par \}
\par 
\par \hich\af13\dbch\af13\loch\f13 static inline int fsuser(void)
\par \{
\par \tab \hich\af13\dbch\af13\loch\f13 if (!issecure(SECURE_NOROOT) && current->fsuid == 0) \{
\par \tab \tab \hich\af13\dbch\af13\loch\f13 current->flags |= PF_SUPERPRIV;
\par \tab \tab \hich\af13\dbch\af13\loch\f13 return 1;
\par \tab \}
\par \tab \hich\af13\dbch\af13\loch\f13 return 0;
\par \}
\par 
\par \hich\af13\dbch\af13\loch\f13 /*
\par \hich\af13\dbch\af13\loch\f13  * capable() checks for a particular capability.  
\par \hich\af13\dbch\af13\loch\f13  * New privilege checks should use th\hich\af13\dbch\af13\loch\f13 is interface, rather than suser() or
\par \hich\af13\dbch\af13\loch\f13  * fsuser(). See include/linux/capability.h for defined capabilities.
\par \hich\af13\dbch\af13\loch\f13  */
\par 
\par \hich\af13\dbch\af13\loch\f13 static inline int capable(int cap)
\par \{
\par \hich\af13\dbch\af13\loch\f13 #if 1 /* ok now */
\par \tab \hich\af13\dbch\af13\loch\f13 if (cap_raised(current->cap_effective, cap))
\par \hich\af13\dbch\af13\loch\f13 #else
\par \tab \hich\af13\dbch\af13\loch\f13 if (cap_is_fs_cap(cap) ? current->f\hich\af13\dbch\af13\loch\f13 suid == 0 : current->euid == 0)
\par \hich\af13\dbch\af13\loch\f13 #endif
\par \tab \{
\par \tab \tab \hich\af13\dbch\af13\loch\f13 current->flags |= PF_SUPERPRIV;
\par \tab \tab \hich\af13\dbch\af13\loch\f13 return 1;
\par \tab \}
\par \tab \hich\af13\dbch\af13\loch\f13 return 0;
\par \}
\par 
\par \hich\af13\dbch\af13\loch\f13 /*
\par \hich\af13\dbch\af13\loch\f13  * Routines for handling mm_structs
\par \hich\af13\dbch\af13\loch\f13  */
\par \hich\af13\dbch\af13\loch\f13 extern struct mm_struct * mm_alloc(void);
\par 
\par \hich\af13\dbch\af13\loch\f13 extern struct mm_struct * start_lazy_tlb(void);
\par \hich\af13\dbch\af13\loch\f13 ext\hich\af13\dbch\af13\loch\f13 ern void end_lazy_tlb(struct mm_struct *mm);
\par 
\par \hich\af13\dbch\af13\loch\f13 /* mmdrop drops the mm and the page tables */
\par \hich\af13\dbch\af13\loch\f13 extern inline void FASTCALL(__mmdrop(struct mm_struct *));
\par \hich\af13\dbch\af13\loch\f13 static inline void mmdrop(struct mm_struct * mm)
\par \{
\par \tab \hich\af13\dbch\af13\loch\f13 if (atomic_dec_and_test(&mm->mm_count))
\par \tab \tab \hich\af13\dbch\af13\loch\f13 __mmdrop(mm\hich\af13\dbch\af13\loch\f13 );
\par \}
\par 
\par \hich\af13\dbch\af13\loch\f13 /* mmput gets rid of the mappings and all user-space */
\par \hich\af13\dbch\af13\loch\f13 extern void mmput(struct mm_struct *);
\par \hich\af13\dbch\af13\loch\f13 /* Remove the current tasks stale references to the old mm_struct */
\par \hich\af13\dbch\af13\loch\f13 extern void mm_release(void);
\par 
\par \hich\af13\dbch\af13\loch\f13 /*
\par \hich\af13\dbch\af13\loch\f13  * Routines for handling the fd arrays
\par \hich\af13\dbch\af13\loch\f13  */
\par \hich\af13\dbch\af13\loch\f13 extern st\hich\af13\dbch\af13\loch\f13 ruct file ** alloc_fd_array(int);
\par \hich\af13\dbch\af13\loch\f13 extern int expand_fd_array(struct files_struct *, int nr);
\par \hich\af13\dbch\af13\loch\f13 extern void free_fd_array(struct file **, int);
\par 
\par \hich\af13\dbch\af13\loch\f13 extern fd_set *alloc_fdset(int);
\par \hich\af13\dbch\af13\loch\f13 extern int expand_fdset(struct files_struct *, int nr);
\par \hich\af13\dbch\af13\loch\f13 extern void free_fdset(fd_set *, int);
\par 
\par \hich\af13\dbch\af13\loch\f13 extern int  copy_thread(int, unsigned long, unsigned long, unsigned long, struct task_struct *, struct pt_regs *);
\par \hich\af13\dbch\af13\loch\f13 extern void flush_thread(void);
\par \hich\af13\dbch\af13\loch\f13 extern void exit_thread(void);
\par 
\par \hich\af13\dbch\af13\loch\f13 extern void exit_mm(struct task_struc\hich\af13\dbch\af13\loch\f13 t *);
\par \hich\af13\dbch\af13\loch\f13 extern void exit_files(struct task_struct *);
\par \hich\af13\dbch\af13\loch\f13 extern void exit_sighand(struct task_struct *);
\par 
\par \hich\af13\dbch\af13\loch\f13 extern void daemonize(void);
\par 
\par \hich\af13\dbch\af13\loch\f13 extern int do_execve(char *, char **, char **, struct pt_regs *);
\par \hich\af13\dbch\af13\loch\f13 extern int do_fork(unsigned long, unsigned long, struct pt_\hich\af13\dbch\af13\loch\f13 regs *, unsigned long);
\par 
\par \hich\af13\dbch\af13\loch\f13 extern void FASTCALL(add_wait_queue(wait_queue_head_t *q, wait_queue_t * wait));
\par \hich\af13\dbch\af13\loch\f13 extern void FASTCALL(add_wait_queue_exclusive(wait_queue_head_t *q, wait_queue_t * wait));
\par \hich\af13\dbch\af13\loch\f13 extern void FASTCALL(remove_wait_queue(wait_queue_head_t *q\hich\af13\dbch\af13\loch\f13 , wait_queue_t * wait));
\par 
\par \hich\af13\dbch\af13\loch\f13 #define __wait_event(wq, condition) \tab \tab \tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13 do \{\tab \tab \tab \tab \tab \tab \tab \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 wait_queue_t __wait;\tab \tab \tab \tab \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 init_waitqueue_entry(&__wait, current);\tab \tab \tab \tab \\
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 add_wait_queue(&wq, &__wait);\tab \tab \tab \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 for (;;) \{\tab \tab \tab \tab \tab \tab \tab \\
\par \tab \tab \hich\af13\dbch\af13\loch\f13 set_current_state(TASK_UNIN\hich\af13\dbch\af13\loch\f13 TERRUPTIBLE);\tab \tab \\
\par \tab \tab \hich\af13\dbch\af13\loch\f13 if (condition)\tab \tab \tab \tab \tab \tab \\
\par \tab \tab \tab \hich\af13\dbch\af13\loch\f13 break;\tab \tab \tab \tab \tab \tab \\
\par \tab \tab \hich\af13\dbch\af13\loch\f13 schedule();\tab \tab \tab \tab \tab \tab \\
\par \tab \}\tab \tab \tab \tab \tab \tab \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 current->state = TASK_RUNNING;\tab \tab \tab \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 remove_wait_queue(&wq, &__wait);\tab \tab \tab \tab \\
\par \}\hich\af13\dbch\af13\loch\f13  while (0)
\par 
\par \hich\af13\dbch\af13\loch\f13 #define wait_event(wq, condition) \tab \tab \tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13 do \{\tab \tab \tab \tab \tab \tab \tab \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 if (condition)\tab  \tab \tab \tab \tab \tab \tab \\
\par \tab \tab \hich\af13\dbch\af13\loch\f13 break;\tab \tab \tab \tab \tab \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 __wait_event(wq, condition);\tab \tab \tab \tab \tab \\
\par \}\hich\af13\dbch\af13\loch\f13  while (0)
\par 
\par \hich\af13\dbch\af13\loch\f13 #define __wait_event_interruptible(wq, condition, ret)\tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13 do \{\tab \tab \tab \tab \tab \tab \tab \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 wait_queue_t __wait;\tab \tab \tab \tab \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 init_waitqueue_entry(&__wait, current);\tab \tab \tab \tab \\
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 add_wait_queue(&wq, &__\hich\af13\dbch\af13\loch\f13 wait);\tab \tab \tab \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 for (;;) \{\tab \tab \tab \tab \tab \tab \tab \\
\par \tab \tab \hich\af13\dbch\af13\loch\f13 set_current_state(TASK_INTERRUPTIBLE);\tab \tab \tab \\
\par \tab \tab \hich\af13\dbch\af13\loch\f13 if (condition)\tab \tab \tab \tab \tab \tab \\
\par \tab \tab \tab \hich\af13\dbch\af13\loch\f13 break;\tab \tab \tab \tab \tab \tab \\
\par \tab \tab \hich\af13\dbch\af13\loch\f13 if (!signal_pending(current)) \{\tab \tab \tab \tab \\
\par \tab \tab \tab \hich\af13\dbch\af13\loch\f13 schedule();\tab \tab \tab \tab \tab \\
\par \tab \tab \tab \hich\af13\dbch\af13\loch\f13 continue;\tab \tab \tab \tab \tab \\
\par \tab \tab \}\tab \tab \tab \tab \tab \tab \tab \\
\par \tab \tab \hich\af13\dbch\af13\loch\f13 ret = -ERESTARTSYS;\tab \tab \tab \tab \tab \\
\par \tab \tab \hich\af13\dbch\af13\loch\f13 break;\tab \tab \tab \tab \tab \tab \tab \\
\par \tab \}\tab \tab \tab \tab \tab \tab \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 current->state = TASK_RUNNING;\tab \tab \tab \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 remove_wait_queue(&wq, &__wait);\tab \tab \tab \tab \\
\par \}\hich\af13\dbch\af13\loch\f13  while (0)
\par \tab 
\par \hich\af13\dbch\af13\loch\f13 #define wait_event_interruptible(wq, condition)\tab \tab \tab \tab \\
\par \hich\af13\dbch\af13\loch\f13 (\{\tab \tab \tab \tab \tab \tab \tab \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 int __ret = 0;\tab \tab \tab \tab \tab \tab \tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 if (!(condition))\tab \tab \tab \tab \tab \tab \\
\par \tab \tab \hich\af13\dbch\af13\loch\f13 __wait_event_interruptible(wq, condi\hich\af13\dbch\af13\loch\f13 tion, __ret);\tab \\
\par \tab \hich\af13\dbch\af13\loch\f13 __ret;\tab \tab \tab \tab \tab \tab \tab \tab \\
\par \}\hich\af13\dbch\af13\loch\f13 )
\par 
\par \hich\af13\dbch\af13\loch\f13 #define REMOVE_LINKS(p) do \{ \\
\par \tab \hich\af13\dbch\af13\loch\f13 (p)->next_task->prev_task = (p)->prev_task; \\
\par \tab \hich\af13\dbch\af13\loch\f13 (p)->prev_task->next_task = (p)->next_task; \\
\par \tab \hich\af13\dbch\af13\loch\f13 if ((p)->p_osptr) \\
\par \tab \tab \hich\af13\dbch\af13\loch\f13 (p)->p_osptr->p_ysptr = (p)->p_ysptr; \\
\par \tab \hich\af13\dbch\af13\loch\f13 if ((p)->p_ysptr) \\
\par \tab \tab \hich\af13\dbch\af13\loch\f13 (p)->p_y\hich\af13\dbch\af13\loch\f13 sptr->p_osptr = (p)->p_osptr; \\
\par \tab \hich\af13\dbch\af13\loch\f13 else \\
\par \tab \tab \hich\af13\dbch\af13\loch\f13 (p)->p_pptr->p_cptr = (p)->p_osptr; \\
\par \tab \}\hich\af13\dbch\af13\loch\f13  while (0)
\par 
\par \hich\af13\dbch\af13\loch\f13 #define SET_LINKS(p) do \{ \\
\par \tab \hich\af13\dbch\af13\loch\f13 (p)->next_task = &init_task; \\
\par \tab \hich\af13\dbch\af13\loch\f13 (p)->prev_task = init_task.prev_task; \\
\par \tab \hich\af13\dbch\af13\loch\f13 init_task.prev_task->next_task = (p); \\
\par \tab \hich\af13\dbch\af13\loch\f13 init_task.prev_task = (p); \\
\par \tab \hich\af13\dbch\af13\loch\f13 (p)->p_ysptr = NULL; \\
\par \tab \hich\af13\dbch\af13\loch\f13 if (((p)->p_osptr = (p)->p_pptr->p_cptr) != NULL) \\
\par \tab \tab \hich\af13\dbch\af13\loch\f13 (p)->p_osptr->p_ysptr = p; \\
\par \tab \hich\af13\dbch\af13\loch\f13 (p)->p_pptr->p_cptr = p; \\
\par \tab \}\hich\af13\dbch\af13\loch\f13  while (0)
\par 
\par \hich\af13\dbch\af13\loch\f13 #define for_each_task(p) \\
\par \tab \hich\af13\dbch\af13\loch\f13 for (p = &init_task ; (p = p->next_task) != &init\hich\af13\dbch\af13\loch\f13 _task ; )
\par 
\par \hich\af13\dbch\af13\loch\f13 #define next_thread(p) \\
\par \tab \hich\af13\dbch\af13\loch\f13 list_entry((p)->thread_group.next, struct task_struct, thread_group)
\par 
\par \hich\af13\dbch\af13\loch\f13 static inline void del_from_runqueue(struct task_struct * p)
\par \{
\par \tab \hich\af13\dbch\af13\loch\f13 nr_running--;
\par \tab \hich\af13\dbch\af13\loch\f13 p->sleep_time = jiffies;
\par \tab \hich\af13\dbch\af13\loch\f13 list_del(&p->run_list);
\par \tab \hich\af13\dbch\af13\loch\f13 p->run_list.next = \hich\af13\dbch\af13\loch\f13 NULL;
\par \}
\par 
\par \hich\af13\dbch\af13\loch\f13 static inline int task_on_runqueue(struct task_struct *p)
\par \{
\par \tab \hich\af13\dbch\af13\loch\f13 return (p->run_list.next != NULL);
\par \}
\par 
\par \hich\af13\dbch\af13\loch\f13 static inline void unhash_process(struct task_struct *p)
\par \{
\par \tab \hich\af13\dbch\af13\loch\f13 if (task_on_runqueue(p)) BUG();
\par \tab \hich\af13\dbch\af13\loch\f13 write_lock_irq(&tasklist_lock);
\par \tab \hich\af13\dbch\af13\loch\f13 nr_threads--;
\par \tab \hich\af13\dbch\af13\loch\f13 unhash_pid(p);
\par \tab \hich\af13\dbch\af13\loch\f13 REMOVE_LINKS(p);
\par \tab \hich\af13\dbch\af13\loch\f13 list_del(&p->thread_group);
\par \tab \hich\af13\dbch\af13\loch\f13 write_unlock_irq(&tasklist_lock);
\par \}
\par 
\par \hich\af13\dbch\af13\loch\f13 static inline void task_lock(struct task_struct *p)
\par \{
\par \tab \hich\af13\dbch\af13\loch\f13 spin_lock(&p->alloc_lock);
\par \}
\par 
\par \hich\af13\dbch\af13\loch\f13 static inline void task_unlock(struct task_struct *p)
\par \{
\par \tab \hich\af13\dbch\af13\loch\f13 spin_unlock(&p\hich\af13\dbch\af13\loch\f13 ->alloc_lock);
\par \}
\par 
\par \hich\af13\dbch\af13\loch\f13 /* write full pathname into buffer and return start of pathname */
\par \hich\af13\dbch\af13\loch\f13 static inline char * d_path(struct dentry *dentry, struct vfsmount *vfsmnt,
\par \tab \tab \tab \tab \hich\af13\dbch\af13\loch\f13 char *buf, int buflen)
\par \{
\par \tab \hich\af13\dbch\af13\loch\f13 char *res;
\par \tab \hich\af13\dbch\af13\loch\f13 struct vfsmount *rootmnt;
\par \tab \hich\af13\dbch\af13\loch\f13 struct dentry *root;
\par \tab \hich\af13\dbch\af13\loch\f13 read\hich\af13\dbch\af13\loch\f13 _lock(&current->fs->lock);
\par \tab \hich\af13\dbch\af13\loch\f13 rootmnt = mntget(current->fs->rootmnt);
\par \tab \hich\af13\dbch\af13\loch\f13 root = dget(current->fs->root);
\par \tab \hich\af13\dbch\af13\loch\f13 read_unlock(&current->fs->lock);
\par \tab \hich\af13\dbch\af13\loch\f13 spin_lock(&dcache_lock);
\par \tab \hich\af13\dbch\af13\loch\f13 res = __d_path(dentry, vfsmnt, root, rootmnt, buf, buflen);
\par \tab \hich\af13\dbch\af13\loch\f13 spin_unlock(&dcache_lock);
\par \tab \hich\af13\dbch\af13\loch\f13 dput(root);
\par \tab \hich\af13\dbch\af13\loch\f13 mntput(rootmnt);
\par \tab \hich\af13\dbch\af13\loch\f13 return res;
\par \}
\par 
\par \hich\af13\dbch\af13\loch\f13 #endif /* __KERNEL__ */
\par 
\par \hich\af13\dbch\af13\loch\f13 #endif
\par }{\hich\af13\insrsid10314595 
\par }}